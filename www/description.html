<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="arca.css">
    <link rel="icon" type="image/png" href="img/panpipe.png">

    <title>Arca musarithmica</title>
    <meta name="description" 
          content="Description of how to compose using Athanasius
                      Kircher’s 1650 device for automatic music composition
                      implemented in Haskell by Andrew Cashner (2021)">

    <!-- syntax highlighting -->
    <link rel="stylesheet" href="highlight/styles/default.min.css">
    <script src="highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>

    <!-- math formatting -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- charts -->
    <script src="https://www.gstatic.com/charts/loader.js"></script>
    <script src="img/iochart.js"></script>
  </head>
  <body>
    <header>
      <h1>ARCA MUSARITHMICA</h1>
      <h3>a device for automatic music composition from 1650</h3>
    </header>
    <nav>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a href="compose.html">Compose</a></li>
        <li><a href="doc/index.html">Code</a></li>
      </ul>
    </nav>
    <main>
      <section id="head">
        <h1>Inside Kircher’s Ark</h1>
        <h3>Contents</h3>
        <ol class="toc">
          <li><a href="#structure">How the ark is structured</a></li>
          <li><a href="#use">How to use the ark</a></li>
          <li><a href="#implementation">Software implementation</a></li>
          <li><a href="#reflections">What does this project tell us about
              computing and composition?</a></li>
          <li><a href="#biblio">Bibliography and related projects</a></li>
        </ol>
      </section>
      <section id="structure">
        <h2>How the ark is structured</h2>

        <p><i>Arca</i> just means <q>box</q>, and as shown in Kircher’s
        overall <a href="index.html#ark-image">illustration</a>, the ark
        contains different kinds of data structures on the outside, on the
        lid, and stored within. After preparing the input text 
        (<a href="#use">see below</a>), the operator uses the
        <i>pinakes</i> (rods) within to extract pre-arranged permutations of
        numbers and rhythmic values. Then they use the table of modes on the
        lid to match the numbers to pitch classes (that is, note names without
        specifying an octave) and accidentals. Finally, the table on the front
        specifies how to inscribe these notes on paper within acceptable
        ranges for the four voices (thereby specifying the initial octave and any
        later adjustments of octaves necessary to keep each voice’s line
        within range. Not included in this illustration are the other elements
        of music notation for which Kircher provides tables in his text,
        including the different possible note values.
        </p>

        <section>
          <h3><i>Syntagmata</i> and <i>pinakes</i> (inside the box)</h3>
          <p>
          The box contains a bevy of <i>pinakes</i> (rods, singular
          <i>pinax</i>), organized into groups called <i>syntagmata</i>
          (singular <i>syntagma</i>).  The design of the rods would seem to
          be inspired by Napier’s bones and other similar calculating devices
          of the time.  Each pinax lists sets of numeric permutations that
          represent four-voice note combinations, and sets of rhythmic
          permutations.
          </p>
          <p>
          The pinakes match up with the metrical structure of
          the poetry being set. Syntagma I, pinax I and II, allow for any
          meter with lines up to six syllables long, as they are just based on
          the length of the penultimate syllable. As a result, these may be
          used to set prose texts as long as they are prepared in appropriate
          groupings of syllables. The remaining pinakes provide for a set of
          Classical Latin poetic meters, from <q>Archilocical Iambic</q> to
          Sapphic meters.
          </p>
          <p>
          There are three syntagmata: the first provides for simple
          note-against-note (homorhythmic) counterpoint, and the second
          provides for florid (melismatic, elaborate) counterpoint including
          imitation and even fugal passages. The third contains a set of
          modifications that can be applied to the previous two syntagmata in
          order to better match prosodic and rhetorical features of the texts.
          Kircher provides the full tables for syntagma I and II, but only an
          outline of syntagma III without enough detail to implement it. (In
          fact he says he has withheld some of the information from the
          general public; though this may have been a bluff.) This software
          fully implements syntagma I and II only, and it is not clear if
          syntagma III could be fully automated based only on Kircher’s
          specification.
          </p>
          <section>
            <h4>Syntagma I: Simple counterpoint</h4>
            <p>
            In syntagma I, there are separate tables of pitch/voice
            permutations (what I call <i>vperms</i>) and rhythm permutations
            (<i>rperms</i>). The user is supposed to choose freely from
            each set and then combine them.
            </p>
            <p>
            This is the rod used to set the hymn <cite>Ave maris stella</cite>
            in simple style: syntagma I, pinax IV, with details showing the
            separate vperms and rperms.
            </p>
            <figure id="s1p4"> 
              <img src="img/Kircher-s1p4.png"
                   alt="Image: The original data tables on the rod in syntagma
                          I, pinax IV, containing at the top, columns of numbers
                          in matrixes for four voices (vperms); and at the bottom,
                          columns of musical notes indicating rhythmic values
                          (rperms)"
                   max-width="400">
              <figcaption>Arca musarithmica, syntagma I, pinax IV, in
                <cite>Musurgia universalis</cite> (1650), book 2, fol.
                83</figcaption>
            </figure>
            <p>
            In many pinakes, the user is supposed to choose from a different
            column based on the order of poetic lines (which Kircher
            confusingly calls <i>strophae</i>, though he means lines not
            stanzas). 
            </p>
            <figure id="s1p4-vperm-detail">
              <img src="img/Kircher-s1p4-vperm-detail.png"
                   alt="Image: Detail of syntagma I, pinax IV, showing the
                          number tables for voice permutations"
                   width="400px">
              <figcaption>Detail of syntagma I, pinax IV: numbers for voice
                permutations</figcaption>
            </figure>
            <p>
            The rperms in this syntagma are divided into three sections by
            meter: for duple meter, <q>triple major</q>, and <q>triple
              minor</q>. These correspond to cut C, cut C3 (or cut C 3/2), and
            C3 (or C 3/2) mensurations.
            </p>
            <figure id="s1p4-rperm-detail">
              <img src="img/Kircher-s1p4-rperm-detail.png"
                   alt="Image: Detail of syntagma I, pinax IV, showing the note
                          tables for rhythm permutations"
                   width="400px">
              <figcaption>Detail of syntagma I, pinax IV: note values for rhythm
                permutations</figcaption>
            </figure>
            <p>
            Kircher does not distinguish systematically between duple-meter
            permutations with a primary semibreve (whole note) subdivision
            (which would be notated with cut C, <i>alla breve</i> time) and
            those with a primary minim (half note) pulse. Perhaps this was
            meant to increase the variety in duple meter, but it can create
            absurd results when the pulse suddenly shifts. This would not be a
            problem for someone choosing the permutations intelligently, but
            since Kircher does not provide a way to distinguish automatically,
            this implementation of the ark can produce some silly results in
            duple meter.
            </p>
            <p>
            The pinakes also include specifications of which modes are
            acceptable.
            </p>
          </section>
          <section>
            <h4>Syntagma II: Florid counterpoint</h4>
            <p>
            In syntagma II, each <i>vperm</i> is matched with a single
            <i>rperm</i> to allow for more complex contrapuntal textures.
            </p>
            <figure id="s2p2a">
              <img src="img/Kircher-s2p2a.png"
                   alt="Image: The original data tables for the rod in syntagma
                          II, pinax II, containing columns of matched sets of
                          voice and rhythm permutations"
                   max-width="400px">
              <figcaption>Arca musarithmica, syntagma II, pinax II, in
                <cite>Musurgia universalis</cite> (1650), book 2, fol. 106
              </figcaption>
            </figure>
            <p>
            This is the rod used to set the same hymn in florid style:
            syntagama II, pinax II. The detail shows the pairs of voice and
            rhythm permutations.
            </p>
            <figure id="s2p2b-detail">
              <img src="img/Kircher-s2p2b-detail.png"
                   alt="Image: Detail of syntagma II, pinax II, showing pairs of
                          voice and rhythm permutations"
                   width="500px">
              <figcaption>Detail of syntagma II, pinax II: pairs of voice and
                rhythm permutations</figcaption>
            </figure>
          </section>
          <section>
            <h4>Automating permutation selection: A problem of theologically
              dangerous chance operations</h4>
            <p>
            To make the system automated, I generate a list of random numbers
            to select the permutations. Kircher and his Jesuit superiors
            probably would have considered this chance operation to be a
            theologically dangerous act, removing human free will and in a
            way, putting God’s providence to the test. I have separated out
            this part of the implementation in the <code>Fortuna</code>
            module, with the necessary cautions in the documentation, and it
            would be possible for a user to supply their own freely chosen
            list of numbers instead, should they be concerned about an audit
            by the Inquisition.
            </p>
          </section>
        </section>
        <section>
          <h3>Palimpsest phonotacticum (front center)</h3>
          <p>
          In the center, adorned by images of ancient and exotic musical
          instruments, the table on the front face shows the settings for the
          <i>palimpsest phonotacticum</i> or music paper.  This chart gives
          the permissible combinations of clefs that specifies the permissible
          ranges for each voice.
          </p>
          <p>
          It also shows the pitch-class values in both <i>cantus durus</i>
          (all-natural accidental signature) and <i>cantus mollis</i>
          (one-flat accidental signature). These were the only two signatures
          used in conservative music of the mid-seventeenth century.
          </p>
        </section>
        <section>
          <h3>Mensa tonographica (underside of lid)</h3>
          <p>
          Under the lid is the <q>table for writing modes</q>, which allows
          the user to look up the pitch names that correspond to the pitch
          numbers in a given mode.  Kircher lists twelve modes, which he
          usually calls <i>toni</i>.  Each mode includes a name, a
          description of the emotional mood or character associated with that
          mode, whether the mode is in <i>cantus durus</i> or
          <i>mollis</i>, and a list of pitches, some with accidentals.
          Kircher’s system of modes does not line up with the older systems
          that most of us learned even in advanced studies of medieval music,
          because it reflects the rapidly changing, chaotic state of modal
          theory in the seventeenth century.
          </p>

          <section>
            <h4>Kircher’s Concept of Mode or <i>Tonus</i></h4>
            <p>
            Many musicians had used a system of twelve church modes at least
            since the time of the theorists Glareanus and Zarlino a century
            earlier. In that system mode I meant that a plainchant melody ended
            on D (the final) with a range from D to the D an octave higher
            (authentic ambitus). Mode II also specified a D final but a range
            from A to A (plagal ambitus). Modes III and IV had an E final with
            authentic and plagal ranges, respectively; and so on, skipping B.
            That system originally developed as a way of classifying traditional
            monophonic (one note at a time) chant melodies.
            </p>
            <p>
            When that system was applied to <em>polyphonic</em> music, it
            usually referred to the final of the lowest voice and the ambitus
            (range) of the Tenor voice. The rules for counterpoint worked
            against some of the special characteristics of the modes: for
            example, when two notes a sixth apart moved into an octave, one was
            supposed to raise the top note or lower the bottom note of the sixth
            (that is, make it a major sixth), which effectively meant that
            <q>leading tones</q> were sharped in almost all modes. Such
            alterations eroded the distinctions between modes until eventually
            most of them sounded like either major or minor 
            (<a href="#Judd:ReniassanceModalTheory">Judd 2002</a>).
            </p>
            <p>
            In between older modal practice and what would emerge as functional
            tonality with major and minor keys, then, were various systems of
            <q>church keys</q> and <i>tonoi</i>
            (<a href="#Barnett:TonalOrganization17C">Barnett 2002</a>). 
            Most of these described practical ways that keyboardists in
            particular would match improvised polyphonic music to traditional
            psalm tones (linked to the modes but not identical with them).
            Kircher’s list of modes is closer to these church keys.
            </p>
          </section>
          <section>
            <h4>Automating <i>musica ficta</i> accidentals: A problem of
              performance practice</h4>
            <p> 
            In practice, the problem of accidentals is a major detriment to
            making the ark fully automatic. Kircher does not list B flats in
            the scales for modes that are in <i>cantus mollis</i>, because
            these are specified by the signatures in the <i>palimpsest</i>
            table below; the flats and sharps he does list are not meant to be
            applied all the time but only in certain situations according to
            the performance-practice traditions of <i>musica ficta</i>. Thus
            a performer, seeing the gesture D–E–D in certain contexts would
            use the rule <i>una nota super la semper est canendum fa</i> to
            apply a flat to the E. Kircher does not provide enough information
            in his specification to automate this aspect completely.
            </p>
            <p>
            This problem is not necessarily a failing of his design, though,
            since it would have been uncommmon to specify such things in
            writing. His machine is designed for automatic
            <em>composition</em>, not performance, and so it provides as much
            information as competent performers would need to execute the
            music. (In the same way the a document-processing program like
            pdfLaTeX converts a source file into PostScript instructions that
            a printer knows how to interpret in order to render the document
            on paper.) This is why I have chosen to render the accidentals
            from this mode table above the staff as suggested <i>musica
              ficta</i>, and this is why the automated MIDI performances on
            this website sometimes sound awful, because the MIDI player does
            not know anything about seventeenth-century performance practice,
            and teaching it that would be an entirely separate programming
            challenge (one worthy to be taken up, though!). 
            </p>
          </section>
        </section>
      </section>
      <section id="use">
        <h2>How to compose music using the ark</h2>

        <ol>
          <li>Kircher expects you to <strong>prepare a text</strong> in Latin or
            another language, with words divided into syllables, marked long or
            short. You can set texts in several Classical meters (like
            Anacreontic or Sapphic), but you can also set irregular verse and
            prose texts.  <ul>
              <li>In this web app, we provide a set of <strong>pre-marked
                  texts</strong>.</li>
              <li>If you download and install the 
                <a href="https://www.bitbucket.org/andrewacashner/kircher.git">command-line
                  version,</a> 
                you can create your own texts that might even have multiple sections
                in different styles and moods!</li>
            </ul>
          </li> 
          <li>Next, Kircher wants you to choose several aspects of the music
            setting you want the ark to create:
            <ul>
              <li>The <strong>style</strong> and texture of the music:
                <ol>
                  <li>you can opt for simple, note-against-note counterpoint (like a
                    hymn),</li>
                  <li>or florid, melismatic counterpoint (like a motet, anthem, or
                    even fugue).</li>
                </ol>
              </li>
              <li>The <strong>mood</strong> or character of the text and its
                setting, which determines the choice of one of twelve musical
                modes (<i>tonoi</i>).  
                <p>
                Kircher’s <em>modes</em> are more like <q>church keys</q> and
                don’t line up exactly with the older modes most musicians
                learned.
                </p>
              </li>
              <li>The <strong>musical meter</strong> (technically, mensuration)
                of the setting. 
                <ol>
                  <li>In the simple style, you can choose 
                    <ol>
                      <li>duple meter (C),</li>
                      <li>triple minor (C3, three minims/half notes per metrical
                        unit),</li>
                      <li>or triple major (cut C3, three semibreves/whole notes
                        per metrical unit).</li>
                    </ol>
                    <p>
                    Some duple-meter permutations in the ark have a minim pulse
                    (C) and others have a semibreve pulse (cut C).
                    </p>
                  </li>
                  <li>In florid style, everything is in duple meter (C).</li>
                </ol>
              </li>
            </ul>
          </li>
          <li>If you are operating the ark by hand, you use these input
            parameters to select the proper tables. 
            <ul> 
              <li><strong>Syntagma:</strong> There are three <i>syntagmata</i>
                or large divisions in the ark. For simple style, you select from
                Syntagma I; for florid, use Syntagma II.
                <p>
                Kircher provides a third syntagma as well, but because it would
                be much more difficult if not impossible to make completely
                automatic, we have omitted it from this implementation.
                (An exercise for the reader!)
                </p>
              </li>
              <li><strong>Pinax:</strong> Each syntagma containes a set of
                <q>rods</q> or <i>pinakes</i> (singular, <i>pinax</i>). You
                select the <i>pinax</i> based on the meter of the text.
              </li>
              <li><strong>Column:</strong> Each pinax contain
                several columns of data. The column is either a free choice, or
                is based on the order of lines in the poem.
              </li>
              <li><strong>Voice and rhythm permutations:</strong> Each column
                includes two parts: sets of numbers representing musical pitches
                (we call these <q>voice permutations</q> or vperms), and sets of
                musical notes representing rhythmic durations (<q>rhythm
                  permutations</q> or rperms).
                <ul>
                  <li>In syntagma I (simple counterpoint), the user is supposed
                    to freely choose one set of vperms and one set of
                    rperms. All the musical voices use the same rhythms.
                    <ul>
                      <li>In syntagma I, there are (generally) three sets of
                        rhythm permutation, one for each type of musical meter
                        you can use.</li>
                    </ul>
                    <li>In syntagma II (florid counterpoint), there is a set of
                      rperms that matches up with each vperm, so that there is a
                      specified rhythm for each of the SATB voices. This makes
                      independent contrapuntal voices possible.
                    </li>
                </ul>
                  </li>
            </ul>
              </li>
              <li><strong>Writing the  music down:</strong> Next you lay out what
                Kircher calls the <i>palimpsest phontacticum</i>, or what the rest
                of us call <q>music paper</q>.
                You draw out four staves and put an appropriate combination of clefs
                for the four voices. These determine the octave and range of the
                musical output for each voice. You also add a flat in the key
                signature if your mode is in <i>cantus mollis</i> according to the
                table, and add the appropriate mensuration sign.
              </li>
              <li><strong>Matching pitches, rhythms, and syllables:</strong> For
                each phrase of text, you take the pitch numbers and look them up in
                the table for the given mode in order to get note names. You pair
                these note names with the rhythmic values, or just put rests when
                those are given. You write these values on the staff,
                making certain adjustments as needed.
              </li>
              <li>Kircher describes a variety of <strong>adjustments</strong>, some
                of which are easier to automate (that is, are more completely
                prescribed) than
                others: 
                <ol>
                  <li>If the notes go out of range for that voice (too far above or
                    below the staff), you may shift them up or down by octave as
                    needed.</li>
                  <li>The mode tables specify that you may add sharps or flats on
                    certain notes according to <i>musica ficta</i> rules.</li>
                  <li>You may also do more complicated things like swapping the
                    notes for adjacent voices, which require your own judgment.</li>
                </ol>
              </li>
              </ul>
          </li>
        </ol>
      </section>
      <section id="implementation">
        <h2>Digital Implementation</h2>
        <p>
        In this software we implement only those parts of the ark which are
        completely specified as automatic algorithms. We have tried to follow
        Kircher’s own ways of structuring the data as closely as possible, as
        may be clear from looking at the 
        <a href="doc/index.html"><code>Arca</code> module</a>.
        </p>
        <p>
        Instead of the user’s choice of vperms and rperms we choose to tempt
        fate (from a seventeenth-century Catholic perspective and roll the dice,
        a literally aleatoric method, by using computer-generated pseudo-random
        numbers.  Other elements that depend on the user’s taste and judgment,
        or elements under-specified by Kircher (like text underlay in
        the melismatic Syntagma II) we leave up to our own users’ discretion.
        </p>
        <p>
        I have tried to write the program in a <q>literate programming</q>
        style, and the full documentation and code are available 
        <a href="doc/index.html">on this site</a>.
        </p>
        <section>
          <h3>Parts of the software</h3>
          <p>
          The program uses the following modules.
          </p>
          <dl>
            <dt>Aedifico (<q>I build</q>)</dt>
            <dd>
              This module defines the software versions of these structures
              and the basic methods for accessing them.
            </dd>
            <dt>Arca musarithmica (<q>Box of Musical Numbers,</q> more or less)</dt>
            <dd>
              This module stores the original data of Kircher’s ark in nested
              vectors and lists of integer values and enumeration values
              corresponding to the rhythmic durations, plus the lists of mode
              scales and other information.
            </dd>
            <dt>Lectio (<q>I read</q>)</dt>
            <dd>
              This module creates the system for reading the input texts, which
              are to be written in a custom XML format.
              We extract the parameters like text meter, music meter, and mode;
              and parse the text into sections, sentences, phrases, words, and
              syllables.
            </dd>
            <dt>Fortuna (<q>Chance</q>)</dt>
            <dd>
              This module generates the pseudo-random numbers used to select
              vperms and rperms.
            </dd>
            <dt>Cogito (<q>I think</q>)</dt>
            <dd>
              This module is where the actual <q>musarithmetic</q> occurs, where
              vperm numbers are converted into pitches with accidentals, rperms
              are converted into durations, and octaves are set and adjusted
              according to Kircher’s rules.
              The module stores all this data in internal data structures
              that encode music sections, phrases, and pitches (with pitch
              class, octave, accidental, duration, and syllables). 
            </dd>
            <dt>Scribo (<q>I write</q>)</dt>
            <dd>
              This module writes the data generated by the
              <code>Cogito</code>module to a music-notation language that other
              software can use to put the actual notes on the screen or paper.
              The submodules output to either Lilypond or MEI, the XML format 
              of the <a href="https://www.music-encoding.org/">Music Encoding
                Initiative</a>. 
              The Lilypond module is still available for testing, but I
              stopped developing it some time ago when I shifted focus to MEI.
            </dd>
          </dl>
        </section>
        <section>
          <h3>A tour through the Haskell code</h3>
          <p>
          Let’s get a taste for the Haskell code by following the process from
          building the ark data through reading the input text, setting it to
          music, and writing the output.
          </p>
          <section>
            <h4>Building data structures for a pinax and the whole ark</h4>
            <p>
            This is how we define the data types for the <code>Pinax</code>
            and the <code>Arca</code> itself, in the <code>Aedifico</code>
            module.
            </p>
            <pre>
            <code class="language-haskell">
-- | The ark is a box containing rods (/pinakes/), each of which includes
-- columns with voice and rhythm permutations. The rods are grouped according
-- to style into /syntagmata/, where /syntagma/ 1 is simple homorhythmic
-- counterpoint.
--
-- We implement the 'Column' as a structure with one 'VpermTable' and one
-- 'RpermTable'. 
data Column     = Column {
    colVpermTable :: VpermTable, 
    colRpermTable :: RpermTable
}

-- | A vector of 'Column' instances is a 'Pinax'.
type Pinax      = Vector (Column)

-- | A vector of 'Pinax' instances is a 'Syntagma'.
type Syntagma   = Vector (Pinax)

-- | A vector of 'Syntagma' instances makes up the full 'Arca'.
data Arca = Arca {
    perms      :: Vector (Syntagma),
    modes      :: ModeList,
    systems    :: ModeSystem,
    pinaxModes :: PinaxModeList,
    ranges     :: VoiceRanges
}
</code>
            </pre>

            <p>
            This is how the first column of syntagma 1, pinax 4 (shown above) is
            represented in the submodule
            <code>Arca_musarithmica.Syntagma1.Pinax04</code>.
            </p>
            <pre>
          <code class="language-haskell">
module Arca_musarithmica.Syntagma1.Pinax04 (s1p4) where

import Aedifico
    ( Dur    (..)
    , buildPinax
    )

-- | Pinax 4
s1p4 = buildPinax [c0, c1, c2, c3]

c0 = (c0v, c0r)

c0v =     [
        [ -- 0
            [5, 5, 3, 2, 3, 3],
            [8, 7, 5, 7, 7, 7],
            [3, 2, 3, 4, 5, 5],
            [8, 5, 8, 7, 3, 3]
        ],
        [ -- 1
            [5, 5, 5, 5, 5, 5],
            [8, 8, 8, 7, 8, 8],
            [3, 3, 3, 2, 3, 3],
            [1, 1, 1, 5, 1, 1]
        ],
        [ -- 2
            [8, 2, 3, 6, 5, 5],
            [5, 7, 8, 8, 7, 8],
            [3, 4, 8, 4, 3, 2],
            [8, 7, 6, 4, 5, 1]
        ],
        [ -- 3
            [3, 2, 3, 2, 1, 7],
            [8, 7, 7, 7, 5, 5],
            [5, 5, 5, 4, 3, 2],
            [1, 5, 3, 4, 8, 5]
        ],
        [ -- 4
            [3, 2, 3, 4, 5, 5],
            [8, 7, 8, 2, 7, 7],
            [5, 5, 5, 2, 3, 3],
            [8, 5, 1, 7, 3, 3]
        ],
        [ -- 5
            [5, 5, 5, 4, 5, 5],
            [8, 8, 7, 8, 7, 8],
            [3, 3, 2, 1, 2, 3],
            [1, 1, 5, 6, 5, 1]
        ],
        [ -- 6
            [5, 5, 5, 5, 5, 5],
            [8, 8, 8, 7, 8, 8],
            [3, 3, 3, 2, 3, 3],
            [8, 8, 8, 5, 8, 8]
        ],
        [ -- 7
            [5, 5, 5, 5, 4, 4],
            [7, 7, 7, 7, 7, 7],
            [3, 3, 3, 3, 2, 2],
            [3, 3, 3, 3, 7, 7]
        ],
        [ -- 8
            [5, 5, 4, 4, 5, 5],
            [7, 7, 6, 8, 7, 8],
            [3, 3, 1, 1, 2, 3],
            [3, 3, 4, 6, 5, 1]
        ],
        [ -- 9
            [3, 4, 5, 4, 2, 3],
            [8, 7, 7, 6, 5, 5],
            [5, 4, 3, 8, 7, 8],
            [1, 2, 3, 4, 5, 1]
        ]
    ]

c0r = [
        [ -- Duple
            [[SbD, Mn, Mn, Mn, Sb, Sb]],
            [[MnD, Sm, Mn, Mn, Sb, Sb]],
            [[Mn, Mn, Mn, Mn, Sb, Sb]],
            [[Sm, Sm, Sm, Sm, Sb, Sb]],
            [[SmD, Fs, Sm, Sm, Mn, Mn]],
            [[MnR, Sb, Mn, Mn, Mn, Sb, Sb]],
            [[SmR, Mn, Sm, Sm, Sm, Mn, Sb]],
            [[Sb, Mn, Sb, Mn, Sb, Sb]]
        ],
        [ -- TripleMajor
            [[Br, Sb, Br, Sb, BrD, BrD]], -- assuming penultimate Br is perfect
            [[SbR, Sb, Sb, Br, Sb, BrD, BrD]],
            [[Sb, Sb, Sb, Sb, Br, BrD]]
        ],
        [ -- TripleMinor
            [[Sb, Mn, Sb, Mn, SbD, SbD]], -- likewise for Sb
            [[Mn, Mn, Mn, Mn, Sb, SbD]],
            [[MnR, Mn, Mn, Sb, Mn, SbD, SbD]]
        ]
    ]
</code>
            </pre>
            <p>
            This is the code where we actually build the ark as an internal data
            structure, using pinax data like that shown above along with the
            list of modes, vocal ranges, and other information.
            The values <code>s1</code> and <code>s2</code> contain the data for
            syntagma I and II.
            </p>
            <pre>
          <code class="language-haskell">
arca :: Arca
arca = Arca {
    perms      = fromList [s1, s2],
    modes      = _modeList,
    systems    = _modeSystems,
    pinaxModes = _pinaxModes,
    ranges     = _vocalRanges
}
</code>
            </pre>
          </section>
          <section>
            <h4>Reading a phrase of input text</h4>
            <p>
            In the <code>Lectio</code> module, these are the functions that read
            a string of input text and create a data structure to pass on to the
            <code>Cogito</code> module for setting to music.
            </p>
            <pre>
<code class="language-haskell">
-- | Take a 'String' and create a 'Verbum' structure:
--
--  - strip the text of diacritics by removing 'hyphenChar' and 'accentChar' characters
--  - extract syllables by stripping accents and splitting at hyphens
--  - get syllable count from list created in previous step
--  - get penultimate syllable length from list of syllables /including/
--  accents, using 'penultValue'
newVerbum :: String -&gt; Verbum
newVerbum s = Verbum {
    verbumText   = plaintext, 
    verbumSyl    = plainSyllables,
    sylCount     = length plainSyllables,
    penultLength = penultValue accentSyllables
} where 
    plaintext = filter (flip notElem [hyphenChar, accentChar]) s -- no accents or hyphens
    noAccents = filter (/= accentChar) s
    accentSyllables = wordsBy (== hyphenChar) s          -- list of syllables including accents
    plainSyllables  = wordsBy (== hyphenChar) noAccents  -- list of syllables without accents

-- | Take a simple list of 'Verbum' items and make a 'LyricPhrase' structure from
-- it: the original list is stored as 'phraseText', and the 'phraseSylCount'
-- and 'phrasePenultLength' are calculated from that list.
-- The 'phraseSylCount' is the sum of all the 'sylCount's of the words in the
-- list. The 'phrasePenultLength' is the 'penultLength' of the last list item.
newLyricPhrase :: [Verbum] -&gt; LyricPhrase
newLyricPhrase ls = LyricPhrase {
    phraseText = ls,
    phraseSylCount = sum $ map sylCount ls,
    phrasePenultLength = penultLength $ last ls,
    phrasePosition = 0
}
</code>
            </pre>
          </section>
          <section>
            <h4>Setting that phrase to music</h4>
            <p>
            In the <code>Cogito</code> module, this is the function we use to
            compose the music for single phrase of text.
            </p>
            <pre>
<code class="language-haskell">
-- | Compose the music for a whole 'LyricPhrase' with one permutation from the
-- ark, and package it into a 'MusicPhrase'. Note that this is for a single
-- voice only, not the four SATB voices. 
-- Line up pitches and syllables, skipping rests. In Syntagma I, line up text
-- and notes syllabically (one syllable per note); in syntagma II (florid),
-- lump the text into a single syllable and put it as an incipit text at the
-- beginning of the phrase. (See module description for why Kircher's
-- specification makes this is necessary.)
makeMusicPhrase :: Arca 
                    -&gt; ArkConfig 
                    -&gt; VoiceName
                    -&gt; LyricPhrase 
                    -&gt; Perm 
                    -&gt; MusicPhrase
makeMusicPhrase arca config voiceID phrase perm = MusicPhrase {
        phraseVoiceID = voiceID,
        notes = theseNotes
    } where

        -- Match up pitches and syllables, skipping rests
        theseNotes = map (\(pitch, syllable) -&gt; Note pitch syllable)
            $ zipFill (music voice) syllables isPitchRest blankSyllable

        voice       = stepwiseVoiceInRange (ranges arca) voiceRaw :: Voice
        voiceRaw    = ark2voice arca config penult sylCount lineCount voiceID perm

        range       = ranges arca
        penult      = phrasePenultLength phrase
        sylCount    = phraseSylCount phrase
        lineCount   = phrasePosition phrase

        words = phraseText phrase

        -- In Syntagma II, put the whole phrase of lyrics as a single
        -- syllable under the first note
        syllables = case arkStyle config of
            Simple -&gt; concat $ map makeSyllables words
            Florid -&gt; [Syllable {
                        sylText = unwords $ map verbumText $ phraseText phrase,
                        sylPosition = Only
                       }]
</code>
            </pre>
          </section>
          <section>
            <h4>Encoding the music output in MEI format</h4>
            <p>
            In the <code>Scribo.MEI</code> module, this is how we convert a single
            <code>Note</code> structure to an MEI <code>note</code> element.
            </p>
            <pre>
<code class="language-haskell">
-- ** 'Note' becomes @note@ (pitch with syllable, or rest)

-- | Create an MEI @note@ element from our @Note@ datatype, converting the
-- attributes as needed. If the @Note@ actually contains a rest ('Pitch' with
-- only a 'Dur' in the rest range), then produce a @rest@ element.
note2mei :: Note -&gt; String
note2mei note | isPitchRest pitch = meiRest
              | otherwise         = meiNote 
    where 
        pitch    = notePitch note
        syllable = noteSyllable note

        meiRest  = elementAttr "rest" [meiDur pitch] []

        meiNote  = elementAttr "note"
                    [ fn pitch | fn &lt;- [meiPname, meiOct, meiDur] ]
                    [ meiAccid pitch
                    , element "verse" [meiSyllable syllable]
                    ]
</code>
            </pre>
            <p>
            This, then, is how we render the whole <code>Phrase</code> (one line of
            input text, set to music by the ark) into MEI.
            </p>
            <pre>
<code class="language-haskell">
 -- | Make an XML string containing a list of @note@ elements out of a
-- 'MusicPhrase'; end each phrase with @barline@, except for last in the list.
--
-- Leave the barline of the last phrase up to the next-higher function (end of
-- sentence gets regular bar; end of sentence, double bar; end of
-- section, final bar).
phrase2mei :: (ListPosition, MusicPhrase) -&gt; String
phrase2mei (position, phrase) | position `elem` [ListEnd, ListOnly] 
                                    = meiNotes
                              | otherwise
                                    = meiNotes ++ meiBarline ""
    where meiNotes = concat $ map note2mei $ notes phrase
</code>
            </pre>
          </section>
          <section>
            <h4>Running the ark</h4>
            <p>
            Here is the key part of the application’s main function
            <code>Main.hs</code> (not included in the 
            <a href="doc/index.html">library documentation</a>).
            After importing all the modules and the <code>arca</code>
            structure, the main function processes the command-line arguments
            to get the input and output sources, then it parses and prepares
            the input text (<code>readInput</code> and
            <code>prepareInput</code>), and generates a list of random numbers
            to select permutations for each phrase (<code>inputPerms</code>).
            The key functions are <code>makeMusicScore</code> to generate the
            music and then <code>score2mei</code> to produce the MEI output.
            </p>
            <pre>
            <code class="language-haskell">
let 
    input       = readInput rawInput
    sections    = prepareInput input 
    lengths     = inputPhraseLengths sections
    metadata    = arkMetadata input

perms &lt;- inputPerms lengths

let 
    score = makeMusicScore arca sections perms 
    mei   = score2mei arca metadata score
              </code>
            </pre>
          </section>
        </section>
        <section>
          <h3>Input format</h3>
          <p>
          The ark program accepts input files in a special XML format, using
          certain elements of the Text Encoding Initiative format.
          The file must have a <code>head</code> element with the title and
          author of the words, followed by a <code>text</code> element that
          includes the words to be set to music.
          </p>
          <p>
          Here is an input text for <cite>Ave Regina angelorum</cite>:
          </p>
          <pre>
<code class="language-xml">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;!DOCTYPE arkText SYSTEM "arkText.dtd"&gt;
&lt;arkText&gt;
  &lt;head&gt;
    &lt;title&gt;Ave Regina Angelorum&lt;/title&gt;
    &lt;wordsAuthor&gt;Kircher?&lt;/wordsAuthor&gt;
  &lt;/head&gt;
  &lt;text&gt;
    &lt;section textMeter="IambicumEnneasyllabicum"
      musicMeter="Duple" style="Simple" mode="Mode8"&gt;
    &lt;lg&gt;
      &lt;l&gt;`A-ve Re-`gi-na An-ge-`lo-rum,&lt;/l&gt;
      &lt;l&gt;`A-ve me-`de-la po-pu-`lo-rum,&lt;/l&gt;
      &lt;l&gt;`Sal-ve fons `vi-ta, `sal-ve `por-ta,&lt;/l&gt;
      &lt;l&gt;Ex qua lux `mun-di `no-bis `or-ta.&lt;/l&gt;
    &lt;/lg&gt;
  &lt;/section&gt;
&lt;/text&gt;
&lt;/arkText&gt;
</code>
          </pre>
          <p>
          The text should be divided into one or more sections, and
          subsequently into one or more line groups (<code>lg</code> elements
          for stanzas or paragraphs) and lines (<code>l</code> elements).
          </p>
          <p>
          The following attributes are required at the start of each section:
          </p>
          <dl>
            <dt>style</dt>
            <dd>Simple or Florid</dd>
            <dt>textMeter</dt>
            <dd>One of the following values:
              <dl>
                <dt>Prose</dt>
                <dd>No meter, free, or irregular</dd>

                <dt>Adonium</dt>
                <dd>5  syllables (<code>`--`-</code>)</dd>

                <dt>Dactylicum</dt>
                <dd>6  syllables (<code>`--`--</code>)</dd>

                <dt>IambicumEuripidaeum</dt>
                <dd>6  syllables (<code>`-`-`-</code>)</dd>

                <dt>Anacreonticum</dt>
                <dd>7  syllables, penultimate long</dd>

                <dt>IambicumArchilochicum</dt>
                <dd>8  syllables, penultimate short</dd>

                <dt>IambicumEnneasyllabicum</dt>
                <dd>9  syllables, penultimate long</dd>

                <dt>Enneasyllabicum</dt>
                <dd>9  syllables (generic)</dd>

                <dt>Decasyllabicum</dt>
                <dd>10 syllables, penultimate short</dd>

                <dt>PhaleuciumHendecasyllabicum</dt>
                <dd>11 syllables</dd>

                <dt>Hendecasyllabicum</dt>
                <dd>11 syllables (generic)</dd>

                <dt>Sapphicum</dt>
                <dd>11 syllables, three lines + 5-syllable tag</dd>

                <dt>Dodecasyllabicum</dt>
                <dd>12 syllables, penultimate short</dd>
              </dl>
            </dd>
            <dt>mode</dt>
            <dd>One of the twelve modes as Mode1, Mode2, ... Mode12</dd>
          </dl>
        </section>
        <section>
          <section>
            <h3>Web app</h3>
            <p>
            In the web app, we use Javascript to generate appropriate lists of
            options to select permissible combinations of texts and parameters
            (not every text can be set in every mode, for instance).
            </p>
            <p>
            These selections are passed to a PHP file that selects the
            appropriate pre-written input text. In <q>DIY</q> mode, where you
            select all the parameters yourself, we also use PHP to insert those
            values into the input file. Then we pass the input file to the ark
            and save the MEI-XML output in a variable. 
            </p>
            <p>
            Via Javascript we pass this data to the third-party 
            <a href="https://www.verovio.org/">Verovio</a> app to render the
            musical data to notation, and to the Verovio toolkit to render it
            to MIDI. The Verovio MIDI player allows to make the music audible.
            </p>
          </section>
        </section>
      </section>
      <section id="reflections">
        <h2>What does this project tell us about computing and composition?</h2>
        <section>
          <h3>Concepts of computing in the ark</h3>
          <section id="functions">
            <h4>Tables, data structures, algorithms, and functions</h4>
            <p>
            Chierotti (<a href="#Chierotti:Comporre">1994</a>) says that
            despite Kircher’s use terms like <i>mechanicus</i> and
            <i>artificiosus</i> to describe the <i>arca</i>, the ark is
            really just a container of rods with tables written on them.
            Bumgardner (<a href="#Bumgardner:Kircher">2002</a>) says a related
            device is basically just a <q>recipe box</q>.
            It certainly is important to clarify for technology enthusiasts
            that Kircher’s device, as specified and built in the seventeenth
            century, is really a <em>system</em> for composition that requires
            a human operator, not an automatic machine.
            </p>
            <p>
            But a computation system does not depend for its definition on the
            existence of a automatic mechanism.
            In fact, the modern definitions of computers are independent from
            physical implementation, such as Turing machines and Church's lambda
            calculus. Instead, the key concept is that a computer provides a
            way to convert inputs into outputs, solely through applying
            a series of prescribed, fixed rules for manipulating and
            transforming the data.
            </p>
            <!-- TODO more, sources -->
            <p>
            Even something as simple as a table really represents a mapping of
            inputs to outputs, as in a multiplication table:
            <table>
              <tr><td>0</td><td>1</td><td>2</td></tr>
              <tr><td>1</td><td>1</td><td>2</td></tr>
              <tr><td>2</td><td>2</td><td>4</td></tr>
            </table>
            To multiply two numbers, you find the row of the first number and
            the column of the second; the intersection gives the result.
            </p>
            <p>
            This means that this table may also be understood as a
            mathematical function.
            The basic multiplication is expressed with the function 
            \(f(a, b) = a * b\), which takes two input values and returns
            their product.
            If we feed this function the list of integers 0 through 2 for both
            parameters, then the result is a matrix equivalent to the table above.
            \[f(\{0, 1, 2\}, \{0, 1, 2\}) = \{ \{0, 1, 2\}, \{1, 1, 2\}, \{2,
            2, 4\} \}\]
            <!-- ?? -->
            </p>
            <p>
            The table may also be understood as an embodiment of an algorithm:
            it is produced by following a concrete series of steps, and the
            data within it is accessed by following another set of steps.
            </p>
            <p>
            Kircher’s <i>pinakes</i>, then, could be described in similar
            terms. Just the tables by themselves are a way of structuring data
            so as to map inputs to outputs, at several levels.
            The input parameters of text meter, style, mode, and syllable
            count determine which syntagma, pinax, and column the user must
            choose. Then the user freely chooses a row from the list of vperms
            and rperms, or chooses randomly. The vperms and rperms then
            provide the user with values to input elsewhere. The pitch numbers
            become inputs to the mode table, which returns pitch class names
            and accidentals that can then be input to the table of note
            positions on the staff.
            </p>
            <p>
            We may chart the flow of inputs to outputs as follows. The chart
            focuses on the output of a single note and ignoring the larger
            structural divisions.
            </p>

            <figure id="ioflows">
              <noscript>(You must have Javascript enabled to display this
                chart.)</noscript>
              <div id="sankey_basic"></div>
              <figcaption>
                The entire ark system: Flows from inputs through
                functions to outputs<br> 
                (types: 1, calculated; 2, input by user)
              </figcaption>
            </figure>

            <p>
            The chart does not account for the octave adjustments we make once
            we have put together the whole series of notes, to avoid too-large
            intervals.
            For that we must compare one pitch to the next one.
            In the current, rather straightforward, implementation of that
            function, the octave of a pitch depends on the pitch class and
            octave of the pitch preceding it.
            </p>
            <p>
            The chart matches closely the way the code is actually written in
            Haskell, where every function is written as a series of data types
            moving from input to output. This, for another example, is the
            primary function that takes as input the ark data, the processed
            input text, and the random permutation numbers, and outputs a data
            structure for the entire music score.
            </p>
            <pre>
            <code class="language-haskell">
-- | Compose the music for the whole document as a 'MusicScore', pulling the
-- data from the 'Arca'.
makeMusicScore :: Arca -&gt; [LyricSection] -&gt; [SectionPerm] -&gt; MusicScore
makeMusicScore arca lyricSections sectionPerms = 
    zipWith (makeMusicChorus arca) lyricSections sectionPerms 
</code>
            </pre>
            <p>
            Many of the flows in the chart can be seen clearly in this
            function, which takes the pair of pitch and rhythm values from the
            ark tables and returns a <code>Pitch</code> data structure that
            includes pitch name, accidental, octave, and duration.
            </p>
<pre>
<code class="language-haskell">
-- | Make a pitch from duration and pitch number, getting octave based on voice
-- name using 'voice2octave'. If the duration input is a rest type (e.g.,
-- 'BrR'), then make a 'newRest'; otherwise a 'stdPitch'.
--
-- Adjust the pitch for mode (and thereby standardize it) ('pnumAccidInMode').
-- Adjust the octave to put the pitch in the right range for the voice
-- ('adjustPitchInRange').
pair2Pitch :: VoiceName 
            -&gt; VoiceRanges
            -&gt; Mode
            -&gt; ModeList
            -&gt; ModeSystem
            -&gt; (Dur, Int) -- ^ duration and pitch number 0-7
            -&gt; Pitch
pair2Pitch voice ranges mode modeList systems pair =
    if isRest thisDur 
        then newRest thisDur
        else adjustPitchInRange pitch voice ranges
        where
            pitch = stdPitch RawPitch {
                rawPnum      = fromEnum thisPnumInMode,
                rawAccid     = thisAccid,
                rawAccidType = thisAccidType,
                rawOct       = oct $ pitchOffsetFromFinal,
                rawDur       = thisDur
            } 
            
            thisPnum  = (snd pair) - 1 -- adjust to 0 index
            thisDur   = fst pair

            thisPnumInMode = fst modePitch
            thisAccid      = snd modePitch
            modePitch      = pnumAccidInMode thisPnum mode modeList

            thisAccidType 
                | thisAccid == Na
                    = Implicit
                | thisAccid `elem` [FlFl, Sh, ShSh]
                    = Suggested
                | thisAccid == Fl
                    = if isBflatInSignature thisPnumInMode thisAccid mode systems 
                        then Implicit 
                        else Suggested
                | otherwise 
                    = None
                
            pitchOffsetFromFinal = final `incPitch` thisPnum
            final                = modalFinalInRange mode modeList voice ranges
</code>
</pre>
            <p>
            In conclusion, then, Kircher's entire ark may be represented as a
            single mathematical function mapping an input text and parameters
            (style, mode, etc.) to outputs.  The tables of the ark and the
            rules governing how to use them constitute the transformation
            functions used within that larger function.
            </p>
            <p>
            This hypothesis is proven correct by the present implementation of
            the system in the purely function programming language Haskell.
            The program itself, like every program in Haskell, constitutes a
            set of self-contained mathematical functions. No information is
            passed through the program except by means of such a function.
            This makes it possible to trace very clearly how the input is
            transformed successively by stages into the output (because again,
            functions and algorithms are equivalent).
            This Haskell implementation, then, is more than just a way to
            model or represent Kircher’s system; by rendering his system
            completely in the symbolic language of functions, it stands as 
            mathematical proof that the ark is in fact a coherent system of
            computation.
            Thus a <q>recipe box</q> full of tables, if taken along with
            Kircher’s written specifications, turns out to constitute a
            single, complete algorithm for computing music.
            Certainly, we must exclude certain aspects of the ark that are
            underspecified, but this implementation shows that the system
            still generates (mostly) playable, intelligible music without
            those extra elements.
            </p>

          </section>
          <section id="encoding">
            <h4>Music encoding</h4>
            <p>
            Music encoding has become a fashionable topic in the era of
            digital humanities, and this project uses the most current
            technology for this task, the XML format of the 
            <a href="http://www.music-encoding.org">Music Encoding Initiative</a>
            (MEI).
            This means that the output of the ark program may easily be
            transformed into other formats like MusicXML or Lilypond, or
            be imported into notation software like Dorico, Finale, or
            Sibelius. The music data can be read and analyzed by computers
            and could therefore contribute to the rapidly developing world
            of digital corpus studies.
            </p>
            <p>
            The output of the ark is one encoding of music. Pitches are
            represented as XML elements with attributes specifying pitch
            class, octave, accidental, and lyric text. Here is a portion
            of one automatically generated setting of the same input text
            shown above, <cite>Ave maris stella</cite>, by the
            <code>arca</code> program. This represents the music for the
            first line of text in the Soprano part.
            </p>
            <pre>
                <code class="language-xml">
&lt;staff n="1" corresp="Soprano"&gt;
  &lt;layer n="1"&gt;
    &lt;rest dur="1"/&gt;
    &lt;note pname="a" oct="4" dur="1"&gt;
      &lt;accid accid.ges="n"/&gt;
      &lt;verse&gt;
        &lt;syl con="d" wordpos="i"&gt;A&lt;/syl&gt;
      &lt;/verse&gt;
    &lt;/note&gt;
    &lt;note pname="b" oct="4" dur="1"&gt;
      &lt;accid accid.ges="n"/&gt;
      &lt;verse&gt;
        &lt;syl con="d" wordpos="t"&gt;ve,&lt;/syl&gt;
      &lt;/verse&gt;
    &lt;/note&gt;
    &lt;note pname="c" oct="5" dur="breve"&gt;
      &lt;accid accid.ges="n"/&gt;
      &lt;verse&gt;
        &lt;syl con="d" wordpos="i"&gt;ma&lt;/syl&gt;
      &lt;/verse&gt;
    &lt;/note&gt;
    &lt;note pname="f" oct="4" dur="1"&gt;
      &lt;accid accid.ges="n"/&gt;
      &lt;verse&gt;
        &lt;syl con="d" wordpos="t"&gt;ris&lt;/syl&gt;
      &lt;/verse&gt;
    &lt;/note&gt;
    &lt;note pname="e" oct="4" dur="breve" dots="1"&gt;
      &lt;accid accid.ges="n"/&gt;
      &lt;verse&gt;
        &lt;syl con="d" wordpos="i"&gt;stel&lt;/syl&gt;
      &lt;/verse&gt;
    &lt;/note&gt;
    &lt;note pname="e" oct="4" dur="breve" dots="1"&gt;
      &lt;accid accid.ges="n"/&gt;
      &lt;verse&gt;
        &lt;syl con="d" wordpos="t"&gt;la,&lt;/syl&gt;
      &lt;/verse&gt;
    &lt;/note&gt;
    &lt;barLine/&gt;
                </code>
            </pre>
            <p>
            Kircher’s ark itself, however, also uses its own kind of music
            encoding, in its tables of numbers and rhythmic values as
            shown above. As Chierotti 
            (<a href="#Chierotti:Comporre">1994</a>) notes, musicians
            already used numbers to represent pitches in figured-bass
            notation, where the numbers stood for intervals above the bass
            note. In the ark the numbers could be thought of either as
            intervals above the modal final, or as positions in a list of
            pitches representing the available notes in the mode. In
            either case the numbers then serve as keys to look up in the
            table of modes.
            </p>
            <p>
            Turning notes into numbers had a greater significance, though. 
            The best thinkers of Kircher’s time, like Fermat and Leibniz,
            were trying to use numbers and symbols to represent things in
            the world in a way that allowed for reflection at a more
            abstract and universal level 
            (<a href="#Ifrah:Computing">Ifrah 2001</a>, 70, 77–80, 88–92).
            The description of the ark is preceded by a mathematical
            discussion of combinatorics, a rapidly developing field of
            inquiry at the time. Using numberic combinations to represent
            pitches was a way of abstracting music into a more abstract
            realm in which the materials of music could be manipulated
            purely symbolically. In other words, Kircher's encoding of
            pitches is not just a shorthand for looking up pitches in a
            table; it is a symbolic representation of music intended to
            allow a mathematical approach to music, in line with the
            development of symbolic notation in mathematics at the time.
            </p>
            <p>
            Kircher’s lists of durations to be matched with the pitch
            numbers also drew on existing practices, such as German
            keyboard tabulature, where organists like Matthias Weckmann
            and Dieterich Buxtehude wrote down letter names in one row and
            note values above them.
            Kircher could have gone a step farther here, as I have had to
            do in implementing it, to convert the graphical symbols to
            textual ones (such as <code>Br</code> for a breve), and
            matching those symbols to numbers (as in the enumeration data
            type I use in the program). As numbers, they may be looked up
            in a table and matched to other encodings.
            Kircher did not need to do that, though, because the human
            user of his ark was supposed to simply copy the graphical
            symbol from his table onto the music paper (though one must
            know whether to put the stem up or down, and how to space it
            out).
            </p>
            <p>
            Kircher also does not fully specify the permutations in triple
            meter, because the symbols must be understood contextually.
            In C3 meter, a semibreve followed by a semibreve is perfect
            (three minims long), but a semibreve followed by a minim is
            imperfect (two minims long). Here I had to add information to
            Kircher’s tables that was not originally present, simply
            adding a dot to the perfect semibreves as they would be
            notated in modern notation. Here we can see the same struggle
            that mathematicians of the time faced, to find unambiguous
            symbolic ways of representing concepts; their solutions were
            not complete in this regard, either.
            In fact, even today we do not have a commonly accepted way of
            manipulating music with abstract symbols alone, though XML
            encoding allows us to use the XSLT language and other tools to
            transform MEI-encoded music into other formats, or to extract
            specific information from it.
            </p>
          </section>
        </section>
        <section id="composition">
          <h3>Concepts of composition in the ark</h3>
          <!--
            <li>Composers as craftsmen not artists</li>
            <li>Composers as assemblers of pre-existing conventional
            structures (cf. schemata theory)</li>
            <li>Music as combinatorics</li>
          -->
        </section>
        <section id="influence">
          <h3>Reception and influence of the ark</h3>
          <!--
            <li>Reception and use of Kircher's work</li>
            <li>Relevance to missionary field and colonialism: supposed
            universality of European polyphony; determinism of music vs.
            non-determinism of language</li>
            <li>Comparison to today's machine-composition projects</li>
          -->
        </section>
        <section id="knuth">
          <h3>Kircher, Knuth, and the cranks</h3>
        </section>
      </section>
      <section id="biblio">
        <h2>Bibliography and related projects</h2>
        <section>
          <p>
          Carlo Maria Chierotti’s dissertation and articles 
          (<a href="#Chierotti:KircherDiss">n.d.</a>, 
          <a href="#Chierotti:KircherMirifica">1992</a>, and 
          <a href="#Chierotti:KircherComporre">1994</a>) 
          on the same subject provide a good overview of Kircher’s work and the
          structure and operation of the ark, with some detailed analysis of the
          types of harmonies and cadences in the voice permutations.
          Chierotti views the ark as one the one hand trying to encyclopedically
          capture all musical knowledge and reduce it to simple rules, while on
          the other hand trying to provide users with a tool to <em>expand</em>
          their possibilities for musical creativity and rhetorical expression.
          He does not view the <i>Arca musarithmica</i> as a machine or
          consider its potential as an automatic system, emphasizing instead how
          much interaction is actually demanded from the user in order to
          produce good results.</p>
          <p>
          Like so much else about Kircher, the ark is indeed a contradictory
          blend of nascent empirical/scientific and traditional faith-based ways
          of viewing the world. 
          The goal of my project was to test the extent to which the ark could
          operate as a fully automated system, and therefore whether it could be
          considered a computer. While certain aspects of Kircher’s
          specification must be ignored (or await more advanced programming) to
          eliminate human interventions after the initial inputs, this research
          does demonstrate that it is possible to generate reasonably coherent
          music using only the strict rule-based algorithms and data structures
          of the ark.
          A more discerning user could certainly take the music generated by
          this implementation and apply the kinds of adjustments Kircher himself
          suggests to improve the end product.
          </p>
          <p>
          I view Kircher’s system as an incomplete specification for a fully
          automated system: most of the parts that appear to require human
          intervention are simply under-specified, and rules could be devised to
          automate them.
          Of course Kircher had no way of actually automating the system
          mechanically, any more than Turing did in his initial mathematical
          description of Turing machines.
          The question of whether the device is a computer is not dependent on
          whether there exists a working physical implementation.
          In any case, such an implementation does now exist, in the present
          software.
          </p>
        </section>
        <section>
          <p>
          Jim Bumgardner (<a href="#Bumgardner:Kircher">2009</a>) 
          implemented a different music-computing device by Kircher, the
          <cite>Organum mathematicum</cite>.
          That device was much simpler musically but had the virtue of also
          being able to calculate the date of Easter and lots of other useful
          functions.
          That implementation in Perl allowed a user to set a very small set of
          short texts in simple or florid style.
          It could generate MIDI output, even using vocal synthesis to render
          the actual syllable sounds.
          </p>
          <p>
          Bumgardner highlights both Kircher’s clear intent to build an
          automatic, algorithmic system for composition, and the inconsistencies
          and underspecified elements that undermine that goal. He also
          recognizes Kircher’s ambivalence about the need for random choices in
          order to automate the system fully.
          Both Bumgardner and Chierotti approach Kircher's mode table
          anachronistically rather than in light of newer research in
          seventeenth-century tonal organization 
          (<a href="#Barnett:TonalOrganization17C">Barnett 2002</a>).
          </p>
        </section>
        <section>
          <p>
          Agnes Cäcilie Bohnert’s dissertation 
          (<a href="#Bohnert:Kircher">YEAR</a>) covers Book VIII of the
          <cite>Musurgia</cite> in detail, focusing especially on the
          mathematical treatment of combinatorics at the beginning.  It
          identifies numerous errors in Kircher’s calculations.  Bohnert
          implemented a portion of the ark in Java, but could only
          set short texts in simple style.
          <!-- etc -->
          </p>
        </section>
        <section>
          <h3>References</h3>

          <ul class="bibliography">
            <li id="Barnett:TonalOrganization17C">Barnett, Gregory. 2002.
              <q>Tonal Organization in Seventeenth-Century Music Theory.</q>
              In <a href="#Cambridge:HistoryofTheory">Christensen, <cite>The
                  Cambridge History of Western Music Theory</cite></a>,
              407–455.
            </li>
            <li id="Bohnert:Kircher">Bohnert, Agnes Cäcilie. </li>
            <li id="Bumgardner:Kircher">Bumgardner, Jim. 2009. 
              <a href="https://jbum.com/papers/kircher_paper.pdf">
                <q>Kircher’s Mechanical Composer: A Software
                  Implementation.</q></a>
              Paper presented at the Bridges Conference, Banff.
            </li>
            <li id="Chierotti:KircherDiss">Chierotti, Carlo Mario. n.d. 
              <a href="http://www.kircher.chierotti.it/tesi">[Tesi di laurea
                sulla <cite>Musurgia Universalis</cite> di Athanasius
                Kircher]</a>.
              Laureate thesis, University of Turin.
            </li>
            <li id="Chierotti:KircherMirifica">Chierotti, Carlo Mario. 1992.
              <q>La musurgia mirifica di Athanasius Kircher: la composizione
                musicale alla portata di tutti nell’età barocca.</q>
              <cite>Musica/realtà</cite> 13, no. 37: 107–127.
            </li>
            <li id="Chierotti:KircherComporre">Chierotti, Carlo Mario. 1994.
              <q>Comporre senza conoscere la musica: Athanasius Kircher e le
                ‘Musica mirifica’: un singolare esempio di scienza musicale
                nell’età barocca.</q>
              <cite>Nuova rivista musicale italiana</cite> 28, no. 3: 382–410.
            </li>
            <li id="Cambridge:HistoryofTheory">Christensen, Thomas, ed. 2002.
              <cite>The Cambridge History of Western Music Theory</cite>.
              Cambridge: Cambridge University Press, 2002.
            </li>
            <li id="Findlen:Kircher">Findlen, Paula, ed. 2004.
              <cite>Athanasius Kircher: The Last Man Who Knew
                Everything</cite>.
              New York: Routledge.
            </li>
            <li id="Godwin:KircherTheater">Godwin, Joscelyn. 2009.
              <cite>Athanasius Kircher’s Theater of the World: The Life and
                Work of the Last Man to Search for Universal
                Knowledge</cite>.
              Rochester, VT: Inner Traditions.
            </li>
            <li id="Ifrah:Computing">Ifrah, Georges. 2001.
              <cite>The Universal History of Computing: From the Abacus to
                the Quantum Computer</cite>.
              Trans. by E. F. Harding.
              New York: John Wiley &amp; Sons, Inc.
            </li>
            <li id="Judd:RenaissanceModalTheory">Judd, Cristle Collins. 2002.
              <q>Renaissance Modal Theory: Theoretical, Compositional, and
                Editorial Perspectives.</q>
              In <a href="#Cambridge:HistoryofTheory">Christensen, <cite>The
                  Cambridge History of Western Music Theory</cite></a>,
              364–406.
            </li>
            <li id="Kircher:Musurgia">Kircher, Athanasius. 1650.
              <cite>Musurgia universalis, sive Ars magna consoni et dissoni
                in X. libros digesta</cite>.
              Rome.
            </li>
          </ul>
        </section>
      </section>
    </main>
    <footer>
      Copyright © 2021 Andrew A. Cashner. All rights reserved.
    </footer>
  </body>
</html>
