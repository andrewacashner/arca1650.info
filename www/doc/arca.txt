-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Bitbucket at
--   <a>https://bitbucket.org/andrewacashner/kircher/src/master/arca/README.md</a>
@package arca
@version 0.1.0.0


-- | This module provides the data structures and methods for storing the
--   data of Kircher's ark and then extracting it. (*aedifico* = Latin, "I
--   build") The <tt>Arca_musarithmica</tt> module actually builds it.
--   
--   <h1>Kircher's specification</h1>
--   
--   As described in Kircher's <i>Musurgia universalis</i> (Rome, 1650),
--   book 8, the ark is a box containing rods (<i>pinakes</i>), each of
--   which includes columns with voice and rhythm permutations. The rods
--   are grouped according to style into <i>syntagmata</i>, where
--   <i>syntagma</i> 1 is simple homorhythmic counterpoint. There are two
--   surviving exemplars of physical implementations of the ark.
--   
--   The top part of Kircher's "rods" contain tables table of numbers with
--   four rows, where the numbers represent pitch offsets from a modal base
--   note, and the rows are the notes for the four voice parts SATB. Each
--   table represents the notes to set a single phrase of text with a given
--   number of syllables.
--   
--   <h1>Implementation</h1>
--   
--   This module implements analogous data structures using Haskell types
--   and defines methods for building the ark from input data, and for
--   accessing each element of the ark data.
--   
--   It also defines the data types needed for the other modules.
--   
--   <h2>Structure of the ark in Haskell implementation (simplified)</h2>
--   
--   <pre>
--   Arca
--       vperms
--           Arca                     = Vector (Syntagma)
--           Syntagma                 = Vector (Pinax)
--           Pinax                    = Vector (Column)
--           Column { colVpermTable } = VpermTable
--           VpermTable { vperms }    = Vector (VpermChoir)
--           VpermChoir               = Vector (Vperm)
--           Vperm                    = [Int]
--   
--       rperms
--           Arca                     = Vector (Syntagma)
--           Syntagma                 = Vector (Pinax)
--           Pinax                    = Vector (Column)
--           Column { colRpermTable } = RpermTable
--           RpermTable               = Vector (RpermMeter)
--           RpermMeter { rperms }    = Vector (RpermChoir)
--           RpermChoir               = Vector (Rperm)
--           Rperm                    = [Dur]
--   </pre>
--   
--   <h3>Accessing perms directly</h3>
--   
--   The test module <tt>Spec.hs</tt> shows how to access all of the ark
--   data directly. These notes might clarify how to reach individual ark
--   vperms or rperms.
--   
--   <pre>
--   vperms
--        perms arca          :: Vector (Vector (Vector Column))
--        colVpermTable       :: VpermTable
--        vperms vpermTable   :: Vector (Vector [Int])
--   
--        vperm :: [Int]
--        vperm = vperms table ! vpermIndex ! voiceIndex
--        where
--            table  = colVpermTable $ column ! columnIndex
--            column = perms arca ! syntagmaIndex ! pinaxIndex ! columnIndex
--   
--   rperms
--        rperm :: [Dur]
--        rperm = rperms table ! rpermMeterIndex ! rpermVoiceIndex
--        where
--            table  = colVpermTable $ column ! columnIndex
--            column = perms arca ! syntagmaIndex ! pinaxIndex ! columnIndex
--   </pre>
module Aedifico

-- | Pitches
--   
--   The <a>Pnum</a> is a 0-indexed diatonic pitch-class number, C through
--   C an octave higher. (In Kircher's 1-indexed system he uses both 1 and
--   8 for C so we must be able to tell the difference.)
data Pnum
PCc :: Pnum
PCd :: Pnum
PCe :: Pnum
PCf :: Pnum
PCg :: Pnum
PCa :: Pnum
PCb :: Pnum

-- | C an octave higher
PCc8 :: Pnum
Rest :: Pnum

-- | Convert any integer to a <a>Pnum</a>
toPnum :: Int -> Pnum

-- | Accidentals
data Accid

-- | double flat
FlFl :: Accid

-- | flat
Fl :: Accid

-- | natural
Na :: Accid

-- | sharp
Sh :: Accid

-- | double sharp
ShSh :: Accid

-- | when note is a rest
AccidNil :: Accid

-- | Octaves
--   
--   We set octave numbers in the Helmholtz system (middle C = C4); we only
--   need the enum <a>OctNil</a> if the note is a rest.
--   
--   <b>TODO</b> check
data Octave
OctNil :: Octave

-- | Voices
--   
--   The ark always produces four-voice polyphony.
data VoiceName
Soprano :: VoiceName
Alto :: VoiceName
Tenor :: VoiceName
Bass :: VoiceName

-- | Vocal Ranges
type VoiceRanges = [(Pitch, Pitch)]

-- | Duration values
--   
--   We use the mensural names; first the base values, then dotted
--   variants, then a series marked as rest values.
data Dur

-- | unset
DurNil :: Dur

-- | breve
Br :: Dur

-- | semibreve
Sb :: Dur

-- | minim
Mn :: Dur

-- | semiminim
Sm :: Dur

-- | fusa
Fs :: Dur

-- | dotted breve
BrD :: Dur

-- | dotted semibreve
SbD :: Dur

-- | dotted minim
MnD :: Dur

-- | dotted semiminim
SmD :: Dur

-- | dotted fusa
FsD :: Dur

-- | longa rest
LgR :: Dur

-- | breve rest
BrR :: Dur

-- | semibreve rest
SbR :: Dur

-- | minim rest
MnR :: Dur

-- | semiminim rest
SmR :: Dur

-- | fusa rest
FsR :: Dur

-- | How should the accidental be displayed? (Needed for MEI)
data AccidType

-- | No accidental
None :: AccidType

-- | MEI accid
Written :: AccidType

-- | MEI accid.ges
Implicit :: AccidType

-- | MEI accid + func="edit"
Suggested :: AccidType

-- | A <a>Pitch</a> stores the essential information for notating a single
--   note.
data Pitch
Pitch :: Pnum -> Int -> Dur -> Accid -> AccidType -> Pitch

-- | Enum for diatonic pitch number
[pnum] :: Pitch -> Pnum

-- | Helmholtz system, middle C = 4
[oct] :: Pitch -> Int

-- | Duration, one of <tt>Dur</tt> enum
[dur] :: Pitch -> Dur

-- | Accidental
[accid] :: Pitch -> Accid

-- | Type of accidental for display
[accidType] :: Pitch -> AccidType

-- | Make a pitch with only <a>pnum</a> and octave, no duration or
--   accidental
simplePitch :: (Pnum, Int) -> Pitch

-- | Kircher only seems to allow for duple (not making distinction between
--   C and cut C), cut C 3 (triple major) and C3 (triple minor).
--   
--   <b>TODO</b> Should we distinguish between C and cut C duple?
data MusicMeter
Duple :: MusicMeter
TripleMajor :: MusicMeter
TripleMinor :: MusicMeter

-- | Select meter by string
toMusicMeter :: String -> MusicMeter

-- | Text meter (of input text, distinguished from musical meter of
--   setting)
data TextMeter
TextMeterNil :: TextMeter

-- | No meter, free, or irregular
Prose :: TextMeter

-- | Prose, 2-6 syllabels, penultimate is long
ProseLong :: TextMeter

-- | Prose, 2-6 syllables, penultimate is short
ProseShort :: TextMeter

-- | 5 syllables (<tt>`--`-</tt>)
Adonium :: TextMeter

-- | 6 syllables (<tt>`--`--</tt>)
Dactylicum :: TextMeter

-- | 6 syllables (<tt><a>-</a>-`-</tt>)
IambicumEuripidaeum :: TextMeter

-- | 7 syllables, penultimate long
Anacreonticum :: TextMeter

-- | 8 syllables, penultimate short
IambicumArchilochicum :: TextMeter

-- | 9 syllables, penultimate long
IambicumEnneasyllabicum :: TextMeter

-- | 9 syllables (generic)
Enneasyllabicum :: TextMeter

-- | 10 syllables, penultimate short
Decasyllabicum :: TextMeter

-- | 11 syllables
PhaleuciumHendecasyllabicum :: TextMeter

-- | 11 syllables (generic)
Hendecasyllabicum :: TextMeter

-- | 11 syllables, three lines + 5-syllable tag
Sapphicum :: TextMeter

-- | 12 syllables, penultimate short
Dodecasyllabicum :: TextMeter

-- | Select text meter by string
toTextMeter :: String -> TextMeter

-- | Get maximum number of syllables for a TextMeter
maxSyllables :: TextMeter -> Int

-- | The choice of style determines which of Kircher's three
--   <i>syntagmata</i> we select. <a>Simple</a> style calls up Syntagma 1
--   for simple, note-against-note (first-species) homorhythmic
--   counterpoint. <a>Florid</a> style calls up Syntagma 2 for syllabic,
--   imitative, and even in some permutations fugal counterpoint.
--   
--   <b>TODO</b> There is also a third syntagma, for adding rhetorical
--   figures to simple counterpoint for more nuanced text-setting. We have
--   not yet implemented this, and do not know if it can be fully
--   automated.
data Style

-- | Syllabic, homorhythmic counterpoint (syntagma 1)
Simple :: Style

-- | Melismatic, imitative counterpoint (syntagma 2)
Florid :: Style

-- | Select style by string (used in processing XML input)
toStyle :: String -> Style

-- | Mode
--   
--   Kircher's table of modes is different from the traditional chant
--   modes. They are more like "church keys" or <i>toni</i> for psalm
--   intonations.
data Mode
Mode1 :: Mode
Mode2 :: Mode
Mode3 :: Mode
Mode4 :: Mode
Mode5 :: Mode
Mode6 :: Mode
Mode7 :: Mode
Mode8 :: Mode
Mode9 :: Mode
Mode10 :: Mode
Mode11 :: Mode
Mode12 :: Mode

-- | Select mode by string (e.g., <a>Mode1</a> or <a>Mode12</a> in XML
--   input)
toMode :: String -> Mode

-- | Mode system, <i>durus</i> (natural) or <i>mollis</i> (one flat in the
--   key signature)
data System
Durus :: System
Mollis :: System

-- | The series of <a>System</a> values for the modes
type ModeSystem = Vector (System)

-- | Combination <a>Pnum</a> and <a>Accid</a> used to set a Pitch
type PnumAccid = (Pnum, Accid)

-- | A list of scales, including some notes with accidentals, from Kircher
type ModeList = Vector (Vector (PnumAccid))

-- | Penultimate Syllable Length
--   
--   Every unit of text to be set to music must be marked with either a
--   long or short penultimate syllable.
data PenultLength
Long :: PenultLength
Short :: PenultLength

-- | <a>Pinax</a> maps to <a>TextMeter</a>
data PinaxLabel
Pinax1 :: PinaxLabel
Pinax2 :: PinaxLabel
Pinax3 :: PinaxLabel
Pinax4 :: PinaxLabel
Pinax5 :: PinaxLabel
Pinax6 :: PinaxLabel
Pinax7 :: PinaxLabel
Pinax8 :: PinaxLabel
Pinax9 :: PinaxLabel
Pinax10 :: PinaxLabel
Pinax11 :: PinaxLabel
PinaxNil :: PinaxLabel

-- | Get pinax from textual meter; this depends on the <a>Style</a> because
--   the <i>syntagmata</i> differ in the order of meters, so
--   <a>IambicumEuripidaeum</a> meter in Syntagma 1 is <a>Pinax3</a>, but
--   in Syntagma 2 it is <a>Pinax2</a>.
meter2pinax :: Style -> TextMeter -> PinaxLabel

-- | In prose, determine <a>TextMeter</a> based on penultimate syllable
--   length
proseMeter :: PenultLength -> TextMeter

-- | All the ark settings in one structure: We use this to pass
--   configuration settings through many functions down to the core level
--   of pulling data from the ark.
data ArkConfig
ArkConfig :: Style -> Mode -> MusicMeter -> TextMeter -> ArkConfig
[arkStyle] :: ArkConfig -> Style
[arkMode] :: ArkConfig -> Mode
[arkMusicMeter] :: ArkConfig -> MusicMeter
[arkTextMeter] :: ArkConfig -> TextMeter

-- | The top part of Kircher's "rods" contain tables table of numbers with
--   four rows, where the numbers represent pitch offsets from a modal base
--   note, and the rows are the notes for the four voice parts SATB. Each
--   table represents the notes to set a single phrase of text with a given
--   number of syllables.
--   
--   We implement the notes for one voice as a <a>Vperm</a>, a list of
--   <a>Int</a> values.
type Vperm = [Int]

-- | A vector of four <a>Vperm</a>s makes a <a>VpermChoir</a>.
type VpermChoir = Vector (Vperm)

-- | A Vector of <a>VpermChoir</a>s is a <a>VpermTable</a>, which
--   represents the top part of Kircher's "rods". We need to know the
--   vector length because it varies in different <i>pinakes</i>.
data VpermTable
VpermTable :: Int -> Vector VpermChoir -> VpermTable

-- | length of <a>vperms</a>
[vpermMax] :: VpermTable -> Int
[vperms] :: VpermTable -> Vector VpermChoir

-- | The bottom part of the "rods" contain tables of rhythmic values
--   written with musical notes. In the simple note-against-note style,
--   there is one list of values to match each table of voices.
--   
--   We implement this using our <a>Dur</a> data type for the rhythmic
--   values. An <a>Rperm</a> is a list of <a>Dur</a> values.
type Rperm = [Dur]

-- | In Syntagma I, there is only one set of rhythmic permutation that we
--   apply to all four voices of the <a>VpermChoir</a>. But in Syntagma II,
--   there are groups of four <a>Rperm</a>s that match up with the four
--   voices. So we make a "choir" as a vector of <a>Rperm</a>s, though in
--   Syntagma I this will always just have a single member.
type RpermChoir = Vector (Rperm)

-- | An <a>RpermMeter</a> includes a vector of <a>RpermChoir</a>s all in
--   one meter (see the <a>MusicMeter</a> data type above) and the length
--   of that vector.
--   
--   Kircher has a variable number of <a>Rperm</a>s in the different
--   meters, in each column, so we need to know how many there are.
--   
--   In Syntagma II everything is duple meter so there is just the one
--   meter.
data RpermMeter
RpermMeter :: Int -> Vector RpermChoir -> RpermMeter

-- | length of <a>rperms</a>
[rpermMax] :: RpermMeter -> Int
[rperms] :: RpermMeter -> Vector RpermChoir

-- | The <a>RpermTable</a> is a vector containing all the rhythmic
--   permutations for one of Kircher's "rods".
--   
--   <b>TODO</b>: This implementation may not be sufficient for the more
--   complex styles where there are different rhythms for the four voices.
--   Also, as noted above, we may need to distinguish duple major and duple
--   minor.
type RpermTable = Vector (RpermMeter)

-- | The ark is a box containing rods (<i>pinakes</i>), each of which
--   includes columns with voice and rhythm permutations. The rods are
--   grouped according to style into <i>syntagmata</i>, where
--   <i>syntagma</i> 1 is simple homorhythmic counterpoint.
--   
--   We implement the <a>Column</a> as a structure with one
--   <a>VpermTable</a> and one <a>RpermTable</a>.
data Column
Column :: VpermTable -> RpermTable -> Column
[colVpermTable] :: Column -> VpermTable
[colRpermTable] :: Column -> RpermTable

-- | A vector of <a>Column</a> instances is a <a>Pinax</a>.
type Pinax = Vector (Column)

-- | A vector of <a>Pinax</a> instances is a <a>Syntagma</a>.
type Syntagma = Vector (Pinax)

-- | A vector of <a>Syntagma</a> instances makes up the full <a>Arca</a>.
data Arca
Arca :: Vector Syntagma -> ModeList -> ModeSystem -> VoiceRanges -> Arca
[perms] :: Arca -> Vector Syntagma
[modes] :: Arca -> ModeList
[systems] :: Arca -> ModeSystem
[ranges] :: Arca -> VoiceRanges

-- | Just get a vector value by index, safely (combining <a>fromJust</a>
--   and <a>!?</a>)
getVectorItem :: String -> Vector a -> Int -> a

-- | Getting a <a>Column</a> just requires indexing through nested vectors.
column :: Arca -> Int -> PinaxLabel -> Int -> Column

-- | Getting a <a>VpermChoir</a> means taking the first of the
--   <a>Column</a> 2-tuple; we select which one using a random number (from
--   <tt>Fortuna</tt> module), though the Inquisition forbids chance
--   operations
vperm :: Column -> Int -> VpermChoir

-- | Getting an <a>RpermChoir</a> means taking data from <a>Column</a>,
--   using the meter and a random index (for Kircher, user's choice)
rperm :: Column -> MusicMeter -> Int -> RpermChoir

-- | The user of Kircher's arca needs only to know the number of syllables
--   in a phrase and whether the penultimate syllable is long or short.
--   Then they must freely (?) choose which table in the column.
--   
--   We go straight to a voice and a rhythm permutation, given all the
--   needed variables and an index. Instead of choosing freely we tempt
--   fate and use a random number.
--   
--   We subtract 2 from the number of syllables to get the column index,
--   since the first column in the <i>pinakes</i> is for two-syllable
--   words.
--   
--   <b>TODO</b>: Does <tt>columnIndex - 2</tt> always work?
getVperm :: Arca -> ArkConfig -> Int -> Int -> Int -> VpermChoir

-- | Select the rhythm values for a single phrase from the ark's rhythm
--   permutations (Rperms).
--   
--   In Pinax 9, there is no TripleMinor category of rperms, so we screen
--   that out first.
--   
--   <b>TODO</b>: Using an error, but we could just substitute TripleMajor
--   with a note in the log (if we had a log).
getRperm :: Arca -> ArkConfig -> Int -> Int -> Int -> RpermChoir

-- | The rule for selecting the column index varies depending on the
--   <i>pinax</i>. Pinax 1 and 2 are determined by whether the penultimate
--   syllables is long or short, respectively, and then the column is based
--   on the number of syllables in the phrase. Pinax 3 columns are based on
--   whether the meter is Adonic or Dactylic (5 or six syllables
--   respectively).
--   
--   There are different rules for each syntagma, hence the need for Style
--   input.
columnIndex :: Style -> TextMeter -> Int -> Int -> Int

-- | Select the pitch numbers for a single voice from one of the ark's
--   pitch permutations (<a>Vperm</a>s).
getVoice :: Arca -> ArkConfig -> Int -> Int -> VoiceName -> Int -> Vperm

-- | Voice permutation data: 1-indexed pitch numbers, sets of four voices
--   each, usually ten sets per column
type VpermTableInput = [[Vperm]]

-- | Rhythm permutation data: <a>Dur</a> values, three sets for different
--   meters, each containing either one set per voice permutation set
--   (<i>syntagma I</i>) or a four-voice set to match (<i>syntagma II</i>)
type RpermTableInput = [[[Rperm]]]

-- | Column data: Pairs of input data for voice and rhythm permutations
type ColumnInput = (VpermTableInput, RpermTableInput)

-- | Pinax data: List of data for columns
type PinaxInput = [ColumnInput]

-- | To build the ark from the data in the <tt>Arca/</tt> directory, we
--   must take a singly nested list and make it into a vector of vectors.
--   This allows for the data to be input and maintained more simply, as a
--   nested list of integers and strings, but then converted to vectors for
--   better performance. The innermost layer stays in list format.
--   
--   <b>TODO</b>: Optimize?
fromList2D :: [[a]] -> Vector (Vector a)

-- | Make a new <a>VpermTable</a> that knows its own length: Application of
--   <a>fromList2D</a> to <a>Vperm</a>
buildVpermTable :: VpermTableInput -> VpermTable

-- | Make a new <a>RpermMeter</a> that knows its own length.
newRpermMeter :: [[Rperm]] -> RpermMeter

-- | Build an <a>RpermTable</a> with <a>RpermMeter</a>s that know their
--   length.
buildRpermTable :: RpermTableInput -> RpermTable

-- | Build a <a>Column</a> directly from input data: two nested lists, one
--   for all the voice permutations in the column and the other for all the
--   rhythm permutations. Because we are manually entering Kircher's data
--   for the ark we do not check for validity here, and there are several
--   variations across the <i>syntagmata</i> and <i>pinakes</i> in how the
--   data is structured.
buildColumn :: ColumnInput -> Column

-- | Build a <a>Pinax</a> from pairs of <a>VpermTable</a> and
--   <a>RpermTable</a> data
buildPinax :: PinaxInput -> Pinax

-- | Build a <a>Syntagma</a> from constructed <a>Pinax</a> items (not from
--   raw input)
buildSyntagma :: [Pinax] -> Syntagma

-- | Pull out a single <a>Column</a> given indices
columnFromArca :: Arca -> Int -> Int -> Int -> Column

-- | Pull out a single <a>Vperm</a>, which is a list of <a>Int</a>
vpermFromArca :: Arca -> Int -> Int -> Int -> Int -> Int -> Vperm

-- | Pull out a single <a>Rperm</a>, which is a list of <a>Dur</a>
rpermFromArca :: Arca -> Int -> Int -> Int -> Int -> Int -> Int -> Rperm
instance GHC.Classes.Ord Aedifico.ArkConfig
instance GHC.Classes.Eq Aedifico.ArkConfig
instance GHC.Classes.Eq Aedifico.PinaxLabel
instance GHC.Classes.Ord Aedifico.PinaxLabel
instance GHC.Enum.Enum Aedifico.PinaxLabel
instance GHC.Show.Show Aedifico.PinaxLabel
instance GHC.Classes.Ord Aedifico.PenultLength
instance GHC.Classes.Eq Aedifico.PenultLength
instance GHC.Enum.Enum Aedifico.PenultLength
instance GHC.Show.Show Aedifico.PenultLength
instance GHC.Classes.Ord Aedifico.System
instance GHC.Classes.Eq Aedifico.System
instance GHC.Enum.Enum Aedifico.System
instance GHC.Classes.Ord Aedifico.Mode
instance GHC.Classes.Eq Aedifico.Mode
instance GHC.Enum.Enum Aedifico.Mode
instance GHC.Show.Show Aedifico.Mode
instance GHC.Classes.Ord Aedifico.Style
instance GHC.Classes.Eq Aedifico.Style
instance GHC.Enum.Enum Aedifico.Style
instance GHC.Show.Show Aedifico.Style
instance GHC.Classes.Ord Aedifico.TextMeter
instance GHC.Classes.Eq Aedifico.TextMeter
instance GHC.Enum.Enum Aedifico.TextMeter
instance GHC.Show.Show Aedifico.TextMeter
instance GHC.Classes.Ord Aedifico.MusicMeter
instance GHC.Classes.Eq Aedifico.MusicMeter
instance GHC.Enum.Enum Aedifico.MusicMeter
instance GHC.Classes.Ord Aedifico.Pitch
instance GHC.Classes.Eq Aedifico.Pitch
instance GHC.Show.Show Aedifico.Pitch
instance GHC.Classes.Ord Aedifico.AccidType
instance GHC.Classes.Eq Aedifico.AccidType
instance GHC.Show.Show Aedifico.AccidType
instance GHC.Show.Show Aedifico.Dur
instance GHC.Classes.Ord Aedifico.Dur
instance GHC.Classes.Eq Aedifico.Dur
instance GHC.Enum.Enum Aedifico.Dur
instance GHC.Classes.Ord Aedifico.VoiceName
instance GHC.Classes.Eq Aedifico.VoiceName
instance GHC.Enum.Enum Aedifico.VoiceName
instance GHC.Classes.Ord Aedifico.Octave
instance GHC.Classes.Eq Aedifico.Octave
instance GHC.Enum.Enum Aedifico.Octave
instance GHC.Show.Show Aedifico.Octave
instance GHC.Classes.Ord Aedifico.Accid
instance GHC.Classes.Eq Aedifico.Accid
instance GHC.Enum.Enum Aedifico.Accid
instance GHC.Show.Show Aedifico.Accid
instance GHC.Classes.Ord Aedifico.Pnum
instance GHC.Classes.Eq Aedifico.Pnum
instance GHC.Enum.Enum Aedifico.Pnum
instance GHC.Show.Show Aedifico.Pnum
instance GHC.Show.Show Aedifico.ArkConfig
instance GHC.Show.Show Aedifico.MusicMeter
instance GHC.Show.Show Aedifico.VoiceName


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p1</a>) is for phrases with long
--   penultimate syllables. It contains five columns.
module Arca_musarithmica.Syntagma1.Pinax01

-- | Pinax 1 (<a>s1p1</a>): We build the <a>Pinax</a> from <a>Column</a>s.
--   
--   "Pinax I. Voces Polysyllabae quae penultimam Longam habent."
--   
--   This one is for phrases with a long penultimate syllable. There are
--   five columns (<tt>c0</tt> ... <tt>c4</tt>). All the columns are a
--   2-tuple of a <a>Vperm</a> and an <a>Rperm</a>.
s1p1 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p2</a>) is for phrases with short
--   penultimate syllables. It contains five columns.
module Arca_musarithmica.Syntagma1.Pinax02

-- | Pinax 2, for phrases with short penultimate syllables.
--   
--   "Voces polysyllabae, quae penultimam Breuem habet"
s1p2 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p3</a>) is for poetry in Adonic meter
--   (<tt>`--`-</tt>) or Dactylic (<tt>`--`--</tt>). On paper it contains
--   four columns for each meter (eight total), but there is only one rperm
--   for each side, repeated for each column. So we implement the
--   <i>pinax</i> as having two columns, each 40 vperms long. Column 0 is
--   for Adonic; Column 1, for Dactylic meter.
module Arca_musarithmica.Syntagma1.Pinax03

-- | Pinax 3
s1p3 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p4</a>) is for poetry in
--   Iambic-Euripidaeic meter, 6 syllable lines with pattern <a>-</a>-`-.
--   There are four columns, meant to be used in order of each line in a
--   four-line strophe (though each column is confusingly labeled
--   "stropha"). There is only one <a>RpermTable</a> for all four columns.
module Arca_musarithmica.Syntagma1.Pinax04

-- | Pinax 4
s1p4 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 85) This <i>pinax</i> (<a>s1p5</a>) is for poetry in
--   Anacreontic meter, 7 syllable lines with long penultimate. What appear
--   to be eight columns are really four, as they correspond with verse
--   lines 1--4 as in <tt>Pinax4</tt>. There is only one <a>RpermTable</a>
--   for all four columns.
module Arca_musarithmica.Syntagma1.Pinax05

-- | Pinax 5
s1p5 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 87): "Iambica Archilochica octosyllaba penultima
--   breuia". This <i>pinax</i> (<a>s1p6</a>) is for poetry in Iambic
--   meter, 8-syllable lines with short penultimate. There are four
--   columns, one for each successive line (but called "strophes"). There
--   is only one <a>RpermTable</a> for all four columns.
module Arca_musarithmica.Syntagma1.Pinax06

-- | Pinax 6
s1p6 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 89): "Iambica Enneasyllaba penultima longa". This
--   <i>pinax</i> (<a>s1p7</a>) is for poetry in Iambic meter, 9-syllable
--   lines with long penultimate. There are four columns, one for each
--   successive line (but called "strophes"). There is only one
--   <a>RpermTable</a> for all four columns.
module Arca_musarithmica.Syntagma1.Pinax07

-- | Pinax 7
s1p7 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 91): "Metra Decasyllaba penultima breui". This
--   <i>pinax</i> (<a>s1p8</a>) is for poetry in 10-syllable lines with
--   short penultimate. There are four columns, one for each successive
--   line (but called "strophes"). There is only one <a>RpermTable</a> for
--   all four columns.
module Arca_musarithmica.Syntagma1.Pinax08

-- | Pinax 8
s1p8 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 93): "Musarithmos Melatheticos Poetics continens pro
--   Phaleucijs Hendecasyllabis". This <i>pinax</i> (<a>s1p9</a>) is for
--   poetry in 11-syllable lines (with long penultimate). There are four
--   columns, one for each successive line (but called "strophes"). There
--   is only one <a>RpermTable</a> for all four columns.
--   
--   This pinax only has nine rows of vperms.
--   
--   What look like the normal three groups of rperms are actually duple
--   major (cut C), duple minor (compasillo, C), and triple major (cut C
--   3). There is actually no rperm for triple minor (C3).
module Arca_musarithmica.Syntagma1.Pinax09

-- | Pinax 9
s1p9 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 93): "Pro Metris Sapphicis". This <i>pinax</i>
--   (<a>s1p10</a>) is for poetry in quatrains built of three 11-syllable
--   lines followed by an <a>Adonic</a> five-syllable line. There are four
--   columns, one for each successive line (but called "strophes"), where
--   the fourth column is for the Adonic tag line.
--   
--   There is only one <a>RpermTable</a> for the three 11-syllable columns,
--   and a separate one for the Adonic column.
module Arca_musarithmica.Syntagma1.Pinax10

-- | Pinax 10
s1p10 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 97): "Dodecasyllaba penultima breuia". This
--   <i>pinax</i> (<a>s1p11</a>) is for poetry in quatrains with
--   11-syllable lines with short penultimates. There are four columns, one
--   for each successive line (but called "strophes"). There is only one
--   <a>RpermTable</a> for all four columns.
module Arca_musarithmica.Syntagma1.Pinax11

-- | Pinax 11
s1p11 :: Pinax


-- | "Syntagma I. Melothesias siue Contrapuncti simplicis."
--   
--   Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark.
module Arca_musarithmica.Syntagma1

-- | To build the <i>syntagma</i>, convert the <i>pinakes</i> from lists to
--   vectors.
s1 :: Syntagma


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p1</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms.
--   
--   In one place (p. 103) Kircher says it is for inequal Adonic and
--   Dactylic meters:
--   
--   "Pinax 1. Melotheticus. In quo numeri harmonici pro metris Adoniis
--   &amp; Dactylicis inaequali quidem, sed Florida &amp; Artificioso vocum
--   progressu disponuntur."
--   
--   In the introduction to Syntagma II (p. 102), though, he says it is for
--   hectasyllabic Adonic and Dactylic meters:
--   
--   "<i>Primus Pinax</i> continet Musarithmos floridos &amp; artificiosos
--   pro metris Adonijs &amp; Dactylicis hectasyllabis."
--   
--   Either way, all the permutations are for <i>five</i> syllables except
--   for the florid (melismatic) voices.
--   
--   It is to be used with <i>tonoi</i> 5, 6, 7, 8, 11, and 12.
--   (<b>TODO</b>)
module Arca_musarithmica.Syntagma2.Pinax01

-- | Pinax 1
s2p1 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p2</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms. Kircher intends this for "Iambic, Euripidaeic, and
--   Hectasyllabic meters" (p. 106), with the paradigm being <i>Ave Maris
--   stella</i>.
--   
--   <pre>
--   PINAX II. "Musarithmi Melothesias Floridae siue Artificiose pro metris Iambicis, Euripedaeis, Hectasyllabis"
--   </pre>
--   
--   He does not give any limitations of modes.
module Arca_musarithmica.Syntagma2.Pinax02

-- | Pinax 2
s2p2 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p3</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms. Kircher intends this for "Anacreontic meters" (p.
--   109), with the paradigm being <i>O ter quaterque felix</i>.
--   
--   <pre>
--   PINAX III. "Musarithmos Melothesias Floridae siue Artificiosae contin√®ns.
--   Pro metris Anacreonticis."
--   </pre>
--   
--   This pinax is for <i>toni</i> (modes) 1, 2, 3, 4, 9, and 10.
module Arca_musarithmica.Syntagma2.Pinax03

-- | Pinax 3
s2p3 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p4</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms.
--   
--   Kircher intends this for "pre-iambic archilochical" meters (p. 111),
--   with the paradigm being <i>Veni creator Spiritus</i>.
--   
--   <pre>
--   "PINAX IV. Melothesiae [-as?] floridae &amp; artificiosae Musarithmos continens PreIambicis Archilochijs."
--   </pre>
--   
--   This pinax is for these <i>toni</i> (modes):
--   
--   <ul>
--   <li>strophes 1--2: 5, 6, 7, 8, 11, and 12</li>
--   <li>strophes 3--4: 1, 2, 3, 4, 9, 10</li>
--   </ul>
--   
--   (really?)
module Arca_musarithmica.Syntagma2.Pinax04

-- | Pinax 4
s2p4 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p5</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms.
--   
--   Kircher intends this for meters with nine and ten syllable lines (p.
--   116), with the paradigm being <i>Amant venena parricida</i>.
--   
--   <pre>
--   "PINAX V. Melothesiae [-as?] Floridae &amp; artificiosae Musarithmos continens. Pro metris Enneasyllabis &amp; Decasyllabis."
--   </pre>
--   
--   This pinax is for <i>toni</i> (modes) 1, 2, 3, 4, 9, and 10.
module Arca_musarithmica.Syntagma2.Pinax05

-- | Pinax 5
s2p5 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p6</a>) contains <i>three</i> columns for
--   successive strophes (actually meaning verse lines). Each contains
--   pairs of four-voice vperms and four-voice rperms.
--   
--   Kircher intends this for Saphhic meters with 11-syllable lines (p.
--   119), with the paradigm being <i>Ut queant laxis resonare fibris</i>.
--   Elsewhere he says it is for "Phaleucic/Hendecasyllabic and Sapphic
--   meters".
--   
--   <pre>
--   "PINAX VI. Musarithmos Melothesias Floridae &amp; artificiosae continens. Pro
--   </pre>
--   
--   metris sapphicis quibuslibet Hendecasyllabis."
--   
--   This pinax is for <i>toni</i> (modes) 1, 2, 3, 4, 9, and 10 in all
--   three "strophes."
--   
--   <b>TODO</b>: The problem is that in Sapphic meter there are stanzas of
--   four lines, where the first three are 11 syllables, and the last is
--   five (Adonic). In Syntagma I, Kircher builds this into the pinax, but
--   this one only accounts for those first three lines. We would have to
--   switch to a different pinax for every fourth line.
module Arca_musarithmica.Syntagma2.Pinax06

-- | Pinax 5
s2p6 :: Pinax


-- | "Syntagma II. Musarithmos Melothesias Floridae &amp; Artificiosae
--   continens"
--   
--   Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark.
module Arca_musarithmica.Syntagma2

-- | To build the <i>syntagma</i>, convert the <i>pinakes</i> from lists to
--   vectors.
s2 :: Syntagma


-- | <i>Arca musarithmica Athanasii Kircheri Societatis Iesu MDCL.</i>
--   
--   This module builds Kircher's ark as a Haskell data structure, using
--   the types and methods defined in the <tt>Aedifico</tt> module (see
--   that module for detailed description of the ark's structure and
--   implementation.)
--   
--   Like Kircher's physical implementation, this module is the container
--   for the data grouped by <i>syntagma</i>, each of which holds a group
--   of <i>pinakes</i> (rods with data tables).
--   
--   So far we have implemented only Syntagma 1, simple note-against-note
--   counterpoint.
module Arca_musarithmica

-- | To build the whole ark (<a>arca</a>), take the <i>syntagma</i> data
--   entered as a nested list and convert it to an <a>Arca</a> (which is a
--   vector of vectors down to the <a>Column</a> level).
--   
--   <pre>
--   arca = fromList [s0] :: Arca
--   </pre>
--   
--   <h1>How sub-elements are built</h1>
--   
--   To build the <i>syntagma</i>, convert the <i>pinakes</i> from lists to
--   vectors. s0' has two <i>pinakes</i>: one for long penultimate
--   syllables (<tt>s0p0</tt>) and one for short (<tt>s0p1</tt>).
--   
--   <pre>
--   s0 = fromList [s0p0, s0p1] :: Syntagma
--   </pre>
--   
--   We build the each <a>Pinax</a> from <a>Column</a>s. The first one
--   (<tt>s0p0</tt>) is for phrases with a long penultimate syllable. There
--   are five columns (<tt>c0</tt> ... <tt>c4</tt>). All the columns are a
--   2-tuple of a <a>Vperm</a> and an <a>Rperm</a>:
--   
--   <pre>
--   c0 = (c0v, c0r) :: Column
--   </pre>
--   
--   The first element (<tt>c0v</tt>) is a <a>VpermTable</a> with the pitch
--   numbers:
--   
--   <pre>
--   c0v :: VpermTable
--   c0v = fromList2D
--       [
--           [ -- 0
--               [5, 5],
--               [7, 8],
--               [2, 3],
--               [5, 1]
--           ],
--           [ -- 1
--               [5, 5],
--               [7, 7],
--               [2, 2],
--               [5, 5]
--           ],
--           ...
--       ]
--   </pre>
--   
--   The second element (<tt>c0r</tt>) is an <a>RpermTable</a> with
--   matching rhythm permutations in the three metrical categories:
--   
--   <pre>
--   c0r :: RpermTable
--   c0r = fromList2D
--       [
--           [ -- duple
--               [Sb, Sb],
--               [Mn, Mn],
--               [Sm, Sm],
--               [Fs, Fs],
--               [SbD, Mn],
--               [MnD, Sm],
--               [SmD, Fs]
--           ],
--           [ -- triple major
--               [Br, Sb],
--               [BrD, BrD]
--           ],
--           [ -- triple minor
--               [Sb, Mn]
--           ]
--       ]
--   </pre>
--   
--   The other columns are constructed similarly with the data from
--   Kircher.
arca :: Arca


-- | This module reads (<i>lectio</i>, Latin, "I read") and process input
--   text to be set to music using the ark.
--   
--   <h1>Kircher's specification</h1>
--   
--   Kircher expects the user to prepare a text by segmenting it into
--   phrases according to the poetic meter and prosody. In his description
--   the texts are Latin, but he also demonstrates how the machine could be
--   used with Aramaic and other languages, ideally by Jesuit missionaries.
--   
--   <h1>Implementation</h1>
--   
--   <h2>XML input</h2>
--   
--   In our implementation we also expect the user to mark the input text
--   by dividing the syllables with hyphens and marking the long syllables
--   with accent symbols (<tt>`</tt>, placed before the relevant syllable),
--   for example:
--   
--   <pre>
--   Lau-`da-te `Do-mi-num `om-nis `ter-rae. Al-le-`lu-ia. A-`men.
--   </pre>
--   
--   This implementation takes input in the form of an XML document, in
--   which the text is syllabified and accented as just demonstrated, and
--   divided into one or more sections. In the attributes for each
--   <tt>&lt;section&gt;</tt> element, the user sets the values we need as
--   input for the ark:
--   
--   <ul>
--   <li><i><tt>textMeter</tt></i> e.g., <tt>Prose</tt> or
--   <tt>Adonium</tt></li>
--   <li><i><tt>musicMeter</tt></i> <tt>Duple</tt>, <tt>TripleMinor</tt>,
--   or <tt>TripleMajor</tt></li>
--   <li><i><tt>style</tt></i> <tt>Simple</tt> (= Syntagma I) or
--   <tt>Florid</tt> (= Syntagma II)</li>
--   <li><i><tt>mode</tt></i> e.g., <tt>Mode1</tt></li>
--   </ul>
--   
--   Within each section the text is divided into one or more line groups
--   (<tt>&lt;lg&gt;</tt>) and lines (<tt>&lt;l&gt;</tt>). (These elements
--   are borrowed from TEI.)
--   
--   <h3><b>TODO</b></h3>
--   
--   In Prose meter, Kircher leaves it up to the user to divide the text
--   into phrases. We are currently using a very simple algorithm to divide
--   the text into phrase groups within the correct size range. It would be
--   better to use a more sophisticated algorithm to parse the text into
--   optimal groups.
--   
--   <h2>Reading and parsing the input file</h2>
--   
--   The main function is <a>prepareInput</a>, which reads and parses the
--   file and produces a list of <a>LyricSection</a>s.
--   
--   This module reads the input file, parses the XML tree to extract the
--   text and needed parameters for setting the text (within each section),
--   and then packages the text into its own data structures to pass on to
--   the other parts of the program (<tt>Cogito</tt> for processing and
--   <tt>Scribo</tt> for writing output).
--   
--   <h3>Capturing XML data</h3>
--   
--   The text is first grouped into intermediate data structures that
--   closely reflect the XML structure. Each <tt>&lt;section&gt;</tt>
--   becomes an <a>ArkTextSection</a>, containing a nested list of strings
--   (line groups and lines from XML) and an <a>ArkConfig</a> with the
--   parameters from the XML section attributes. The list of these is
--   packaged into a single <a>ArkInput</a> structure containing metadata
--   for the whole document (taken from the XML <tt>&lt;head&gt;</tt>), and
--   a list of <a>ArkTextSection</a>s.
--   
--   <h3>Preparing for musical setting</h3>
--   
--   The module then processes this data and converts it into a list of
--   <a>LyricSection</a>s that the other modules will use. Below are the
--   structures that are passed on to other modules, from top down. Each
--   structure contains the element below it, plus information about it
--   (length, number of syllables, etc.). To get that information, these
--   structures are created with methods that calculate the data upfront.
--   
--   <ul>
--   <li><i><a>LyricSection</a></i> group of sentences (from
--   <tt>&lt;section&gt;</tt>)</li>
--   </ul>
--   
--   <ul>
--   <li>also contains an <a>ArkConfig</a> with the text-setting
--   parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i><a>LyricSentence</a></i> group of phrases (from
--   <tt>&lt;lg&gt;</tt>)</li>
--   <li><i><a>LyricPhrase</a></i> group of words (from
--   <tt>&lt;l&gt;</tt>)</li>
--   <li><i><a>Verbum</a></i> individual word, broken into syllables</li>
--   </ul>
module Lectio

-- | The character used to demarcate syllables (default <tt>'-'</tt>)
hyphenChar :: Char

-- | The character used at the beginning of syllables to show long (or
--   accented) syllables (default <tt>'`'</tt>)
accentChar :: Char

-- | Header information
data ArkMetadata
ArkMetadata :: String -> String -> ArkMetadata
[arkTitle] :: ArkMetadata -> String
[arkWordsAuthor] :: ArkMetadata -> String

-- | The input to the ark is an <a>ArkConfig</a> element with mode, style,
--   and meter; and a list of strings, each of which will become a
--   <a>LyricSentence</a>
data ArkInput
ArkInput :: ArkMetadata -> [ArkTextSection] -> ArkInput
[arkMetadata] :: ArkInput -> ArkMetadata
[arkTextSections] :: ArkInput -> [ArkTextSection]

-- | A section of input text (from xml section element)
data ArkTextSection
ArkTextSection :: ArkConfig -> [[String]] -> ArkTextSection
[arkConfig] :: ArkTextSection -> ArkConfig

-- | list of <tt>&lt;lg@&gt; containing lists of </tt>&lt;l&gt;@
[arkText] :: ArkTextSection -> [[String]]

-- | Create a <a>QName</a> to search the xml tree
xmlSearch :: String -> QName

-- | Get the text from a node
xmlNodeText :: String -> Element -> String

-- | For each string in list, break text into strings at newlines, strip
--   leading and trailing whitespace, remove empty strings, remove newlines
cleanUpText :: [String] -> [String]

-- | Strip leading and trailing whitespace from a <a>String</a>
strip :: String -> String

-- | Read an XML string and return the data for input to the ark
--   (<a>ArkInput</a>)
readInput :: String -> ArkInput

-- | Parse an XML node tree into a section with configuration and parsed
--   text.
parseSection :: Element -> ArkTextSection

-- | Every syllable is either <a>Long</a> or <a>Short</a>.
type SylLen = PenultLength

-- | Our data type for a word includes the original text of the word, that
--   text chunked into syllables, the count of those syllables, and a
--   marker of whether the penultimate syllable is short or long.
data Verbum
Verbum :: String -> [String] -> Int -> SylLen -> Verbum

-- | original text
[verbumText] :: Verbum -> String

-- | text divided into list of syllables
[verbumSyl] :: Verbum -> [String]

-- | number of syllables
[sylCount] :: Verbum -> Int

-- | length of next-to-last syllable
[penultLength] :: Verbum -> SylLen

-- | A <a>LyricPhrase</a> is a group of <a>Verbum</a> items (words): it
--   contains the list of words, the total count of syllables in the
--   phrase, and a marker for the phrase's penultimate syllable length.
data LyricPhrase
LyricPhrase :: [Verbum] -> Int -> SylLen -> Int -> LyricPhrase

-- | list of words
[phraseText] :: LyricPhrase -> [Verbum]

-- | total syllables in all words
[phraseSylCount] :: LyricPhrase -> Int

-- | length of next-to-last syllable in whole phrase
[phrasePenultLength] :: LyricPhrase -> SylLen

-- | position in list of phrases
[phrasePosition] :: LyricPhrase -> Int

-- | Each sentence includes the number of phrases therein
type PhrasesInLyricSentence = Int

-- | A list of totals of phrases in a section
type PhrasesInLyricSection = [PhrasesInLyricSentence]

-- | A <a>LyricSentence</a> is just a list of <a>LyricPhrase</a> items.
data LyricSentence
LyricSentence :: [LyricPhrase] -> PhrasesInLyricSentence -> LyricSentence
[phrases] :: LyricSentence -> [LyricPhrase]

-- | number of phrases
[sentenceLength] :: LyricSentence -> PhrasesInLyricSentence

-- | A <a>LyricSection</a> includes a list of <a>LyricSentence</a>s and an
--   <a>ArkConfig</a>.
--   
--   Including an <a>ArkConfig</a> structure makes it possible to structure
--   the input text and program the ark to change meters or modes for
--   different sections.
data LyricSection
LyricSection :: ArkConfig -> [LyricSentence] -> LyricSection
[sectionConfig] :: LyricSection -> ArkConfig
[sentences] :: LyricSection -> [LyricSentence]

-- | Get the number of phrases per sentence for a whole section.
sectionPhraseLengths :: LyricSection -> PhrasesInLyricSection

-- | Get the phrase lengths for the whole input structure
inputPhraseLengths :: [LyricSection] -> [PhrasesInLyricSection]

-- | Make a <a>LyricSentence</a> from a list of <a>LyricPhrase</a>s.
newLyricSentence :: [LyricPhrase] -> LyricSentence

-- | Take a simple list of <a>Verbum</a> items and make a
--   <a>LyricPhrase</a> structure from it: the original list is stored as
--   <a>phraseText</a>, and the <a>phraseSylCount</a> and
--   <a>phrasePenultLength</a> are calculated from that list. The
--   <a>phraseSylCount</a> is the sum of all the <a>sylCount</a>s of the
--   words in the list. The <a>phrasePenultLength</a> is the
--   <a>penultLength</a> of the last list item.
newLyricPhrase :: [Verbum] -> LyricPhrase

-- | Take a <a>String</a> and create a <a>Verbum</a> structure:
--   
--   <ul>
--   <li>strip the text of diacritics by removing <a>hyphenChar</a> and
--   <a>accentChar</a> characters</li>
--   <li>extract syllables by stripping accents and splitting at
--   hyphens</li>
--   <li>get syllable count from list created in previous step</li>
--   <li>get penultimate syllable length from list of syllables
--   <i>including</i> accents, using <a>penultValue</a></li>
--   </ul>
newVerbum :: String -> Verbum

-- | Determine the length of the next-to-last in a list of strings. If the
--   list length is 1 or shorter, or if there is no <a>accentChar</a> at
--   the beginning of the penultimate syllable (found using <a>penult</a>),
--   then the result is <a>Short</a>; otherwise <a>Long</a>.
penultValue :: [String] -> SylLen

-- | Return the next-to-last item in a list.
penult :: [a] -> Maybe a

-- | Regroup a phrase int groups of words with total syllable count in each
--   group not to exceed a given maximum.
--   
--   <b>TODO</b>: Replace with more sophisticated algorithm: - what to do
--   if word is longer than maxSyllables? (break it into parts?) - optimize
--   this for best grouping, not just most convenient in-order
rephrase :: Int -> LyricPhrase -> [LyricPhrase]

-- | Prepare the entire input structure
prepareInput :: ArkInput -> [LyricSection]
instance GHC.Classes.Ord Lectio.LyricSection
instance GHC.Classes.Eq Lectio.LyricSection
instance GHC.Show.Show Lectio.LyricSection
instance GHC.Classes.Ord Lectio.LyricSentence
instance GHC.Classes.Eq Lectio.LyricSentence
instance GHC.Show.Show Lectio.LyricSentence
instance GHC.Classes.Ord Lectio.LyricPhrase
instance GHC.Classes.Eq Lectio.LyricPhrase
instance GHC.Show.Show Lectio.Verbum
instance GHC.Classes.Ord Lectio.Verbum
instance GHC.Classes.Eq Lectio.Verbum
instance GHC.Show.Show Lectio.ArkInput
instance GHC.Show.Show Lectio.ArkTextSection
instance GHC.Show.Show Lectio.ArkMetadata
instance GHC.Show.Show Lectio.LyricPhrase


-- | Kircher's ark does require a small amount of free choice on the part
--   of the user, in selecting which voice permutation and rhythm
--   permutation to use from each column. We take the (for Kircher)
--   theologically dangerous route of chance operations and generate a
--   random number for the index of the voice and rhythm permutations.
module Fortuna

-- | A <tt>Perm</tt> stores the random number choices used to select voice
--   and rhythm permutations.
data Perm
Perm :: Int -> Int -> Perm
[voiceIndex] :: Perm -> Int
[rhythmIndex] :: Perm -> Int

-- | Make a pair of random numbers to select vperm and rperm:
--   
--   <ul>
--   <li>vperm is always one of 10 vperms per column</li>
--   <li>rperm lists are variable in length, so we choose a larger number
--   and then take the modulo of the length of the list once it's selected
--   (in <tt>Aedifico</tt>)</li>
--   </ul>
choosePerms :: IO Perm

-- | Each sentence needs a list of perms, one per phrase
type SentencePerm = [Perm]

-- | A list of perms for each sentence in the section
type SectionPerm = [SentencePerm]

-- | Generate a list of <a>Perm</a>s of a given length to match a
--   <tt>Sentence</tt>
sentencePerms :: PhrasesInLyricSentence -> IO SentencePerm

-- | Generate perms for a whole section
sectionPerms :: PhrasesInLyricSection -> IO SectionPerm

-- | Generate perms for the whole input structure
inputPerms :: [PhrasesInLyricSection] -> IO [[SentencePerm]]
instance GHC.Show.Show Fortuna.Perm


-- | This module processes data from the ark to convert it into music
--   (<i>cogito</i>, Latin, "I think").
--   
--   <h1>Overview</h1>
--   
--   This module receives input from the <tt>Lectio</tt> module in the form
--   of a single list of one or more <a>LyricSection</a>s, which contain
--   the parsed text to be set to music and the parameters for setting it.
--   
--   The module uses Kircher's rules to pull the appropriate data from the
--   Arca musarithmica, that is, from the <a>Arca</a> built by the
--   <tt>Aedifico</tt> module. It uses the <tt>Fortuna</tt> module to get
--   lists of random permutation indices.
--   
--   The main function is <a>makeMusicScore</a>, which applies all the
--   necessary rules to select music data from the ark for each phrase of
--   text, using the random permutations when a free choice would otherwise
--   be needed. It takes the numerals and rhythmic symbols from Kircher's
--   <i>pinakes</i> (rods); converts the numerals to pitches according to
--   the mode, and combines the pitches and rhythms (accounting for rests
--   as well).
--   
--   The module creates the <a>MusicScore</a> data structure which contains
--   all the data for the music in hierarchical sections that the
--   <tt>Scribo</tt> module will convert to MEI XML.
--   
--   <h2>Text underlay</h2>
--   
--   Pitches and syllables are stored together in the <a>Note</a> type. In
--   Syntagma I (simple syllabic counterpoint), we store one syllable for
--   each note, skipping rests.
--   
--   In Syntagma II, though, for florid counterpoint, Kircher does not
--   specify how to underlay the text, and the settings have variable
--   numbers of notes in the different voices and between different
--   permutations in the same <i>pinax</i>. The underlay must be left to
--   the human performer, then, and so we just lump all the lyrics for each
--   phrase and put them under the first syllable as a textual incipit.
--   
--   <h2>MEI vs. Lilypond output</h2>
--   
--   We previously set up this module to feed data into the
--   <tt>Scribo.Lilypond</tt> module, using the main function
--   <a>getSymphonia</a>. It treated pitches and lyrics completely
--   separately, which worked in Syntagma I but not in Syntagma II. These
--   functions are still here for safety until I decide to get rid of the
--   Lilypond module or rewrite it.
module Cogito

-- | A <a>RawPitch</a> is the same as a <a>Pitch</a> except instead of a
--   <a>Pnum</a> it has an <a>Int</a>. This allows us to add and subtract
--   from pitches and then use <a>stdPitch</a> to normalize them by
--   adjusting the octave and pitch like the two digits of a base-7 number.
data RawPitch
RawPitch :: Int -> Int -> Dur -> Accid -> AccidType -> RawPitch
[rawPnum] :: RawPitch -> Int
[rawOct] :: RawPitch -> Int
[rawDur] :: RawPitch -> Dur
[rawAccid] :: RawPitch -> Accid
[rawAccidType] :: RawPitch -> AccidType

-- | A <a>Voice</a> is a list of pitches with an identifier for the voice
--   type.
data Voice
Voice :: VoiceName -> [Pitch] -> Voice

-- | Enum for Soprano, Alto, Tenor or Bass
[voiceID] :: Voice -> VoiceName
[music] :: Voice -> [Pitch]

-- | Make a list of voices with same <a>voiceID</a> into one <a>Voice</a>
--   (combine the lists of <a>Pitch</a>es into one)
mergeVoices :: [Voice] -> Voice

-- | A <a>Chorus</a> is a group (list) of four <a>Voice</a> items
--   
--   <b>TODO</b>: We don't actually define it as being four items.
--   <b>TODO</b>: Do we still need this with new MEI setup?
type Chorus = [Voice]

-- | Create a rest (that is, a <a>Pitch</a> with duration only)
--   
--   We make a <a>Pitch</a> but set the <a>pnum</a> to <a>Rest</a>;
--   <a>oct</a> and <a>accid</a> are set to special nil values
--   (<a>OctNil</a>, <a>AccidNil</a>)
--   
--   <b>TODO</b>: We are setting the octave using <tt>fromEnum OctNil</tt>:
--   Isn't this the same as just setting it to zero? Is there a better way
--   to mark this?
newRest :: Dur -> Pitch

-- | Standardize pitch.
--   
--   A <a>Pitch</a> is like a two-digit number in base 7, where the first
--   digit (the "7s") is the octave. If the second digit (the "1s") is over
--   7, we must increment the octave. A "standardized pitch" in our
--   implementation is one that conforms to this requirement, so the
--   <a>stdPitch</a> method takes all the input for a <a>Pitch</a> and does
--   the necessary conversions to set the octave.
--   
--   We need this because Kircher's tables include both pitch number 1 and
--   pitch 8. If pitch input is Kircher's pitch 8, then set pitch num to
--   PcC (0) and add one to octave.
--   
--   <b>TODO</b>: We don't check for values out of range because we know
--   what input we are getting from the ark. Is this okay?
stdPitch :: RawPitch -> Pitch

-- | Increment a pitch by increasing its <a>Pnum</a> pitch number and its
--   octave if necessary (using <a>Pitch</a> structure like a base-7
--   number). Create a new <a>Pitch</a> with incremented <a>Pnum</a> and
--   then standardize it with <a>stdPitch</a> to get correct octave and
--   pitch number.
incPitch :: Pitch -> Int -> Pitch

-- | Is a mode in <i>cantus mollis</i>? Should there be a flat in the key
--   signature?
modeMollis :: Mode -> ModeSystem -> Bool

-- | Adjust a pitch to be in a given mode.
pnumAccidInMode :: Int -> Mode -> ModeList -> PnumAccid

-- | Get the modal final within range for this voice. What pitch = 0 in
--   this mode? What is the lowest octave of that pitch permissible in the
--   range for that voice? Set all the other pitches with reference to
--   that, within the octave between 0--7
modalFinalInRange :: Mode -> ModeList -> VoiceName -> VoiceRanges -> Pitch

-- | What octave is the modal final in for this voice's range?
modalOctaveBase :: Mode -> ModeList -> VoiceName -> VoiceRanges -> Int

-- | Adjust the accidental either toward flats or toward sharps, within the
--   <a>Accid</a> enum. If the accidental is unset we just return the
--   original pitch.
accidentalShift :: Pitch -> Accid -> Pitch

-- | Lower a pitch a semitone, but not past <a>FlFl</a>
flatten :: Pitch -> Pitch

-- | Raise a pitch a semitone, but not past <a>ShSh</a>
sharpen :: Pitch -> Pitch

-- | Convert <a>Pitch</a> to absolute pitch number
absPitch :: Pitch -> Int

-- | Get chromatic offset from C for diatonic pitch classes
dia2chrom :: Pnum -> Int

-- | Are two <a>Pitch</a>es the same chromatic pitch, enharmonically
--   equivalent?
pEq :: Pitch -> Pitch -> Bool

-- | Pitch greater than?
pGt :: Pitch -> Pitch -> Bool

-- | Pitch less than?
pLt :: Pitch -> Pitch -> Bool

-- | Pitch greater than or equal?
pGtEq :: Pitch -> Pitch -> Bool

-- | Pitch less than or equal?
pLtEq :: Pitch -> Pitch -> Bool

-- | Absolute diatonic pitch (octave + pitch)
absPitch7 :: Pitch -> Int

-- | Difference between pitches, diatonic interval
p7diff :: Pitch -> Pitch -> Int

-- | Copy a <a>Pitch</a> (unchanged if <a>Rest</a>), with given function
--   applied to the octave member
octaveAdjust :: Pitch -> (Int -> Int) -> Pitch

-- | Raise the octave by 1
octaveUp :: Pitch -> Pitch

-- | Lower the octave by 1
octaveDown :: Pitch -> Pitch

-- | Check to see if a rhythmic duration is a rest type (the rest enums
--   begin with <a>LgR</a> so we compare with that)
isRest :: Dur -> Bool

-- | Is the <a>Pitch</a> a rest?
isPitchRest :: Pitch -> Bool

-- | Take two lists and zip them together, that is, make a new list of
--   ordered pairs constructed from sequential items of the two lists, BUT:
--   if an element in the first list satisfies a given <tt>test</tt>, make
--   a pair of that element and a sustitute element (<tt>sub</tt>) instead
--   of the corresponding element from the second list.
zipFill :: [a] -> [b] -> (a -> Bool) -> b -> [(a, b)]

-- | Make a pitch from duration and pitch number, getting octave based on
--   voice name using <a>voice2octave</a>. If the duration input is a rest
--   type (e.g., <a>BrR</a>), then make a <a>newRest</a>; otherwise a
--   <a>stdPitch</a>.
--   
--   Adjust the pitch for mode (and thereby standardize it)
--   (<a>pnumAccidInMode</a>). Adjust the octave to put the pitch in the
--   right range for the voice (<a>adjustPitchInRange</a>).
--   
--   <b>TODO</b>: This could also be generalized; we are not checking
--   inputs because we control data input.
pair2Pitch :: VoiceName -> VoiceRanges -> Mode -> ModeList -> ModeSystem -> (Dur, Int) -> Pitch

-- | Is this note a B flat, and if so, is the flat already in the key
--   signature?
isBflatInSignature :: Pnum -> Accid -> Mode -> ModeSystem -> Bool

-- | Get the right starting octave range for each voice type voice2octave
--   :: VoiceName -&gt; Int
voice2octave :: Num p => VoiceName -> p

-- | Is the pitch below the bottom limit of the voice range?
pitchTooLow :: Pitch -> VoiceName -> VoiceRanges -> Bool

-- | Is the pitch above the upper limit of the voice range?
pitchTooHigh :: Pitch -> VoiceName -> VoiceRanges -> Bool

-- | Get the bottom limit of the voice range
lowRange :: VoiceName -> VoiceRanges -> Pitch

-- | Get the top limit of the voice range
highRange :: VoiceName -> VoiceRanges -> Pitch

-- | Adjust a pitch to be in the correct voice range (using
--   <tt>Aedifico.vocalRanges</tt>). If it's in the right range for the
--   voice, leave it alone; if it's too low raise it by an octave, or vice
--   versa if it's too high; keep shifting octaves till it's in range.
adjustPitchInRange :: Pitch -> VoiceName -> VoiceRanges -> Pitch

-- | Is the <a>Pitch</a> within the proper range for its voice?
isPitchInRange :: Pitch -> VoiceName -> VoiceRanges -> Bool

-- | Go through list of pitches and reduce intervals that are more than a
--   seventh
stepwiseInRange :: [Pitch] -> VoiceName -> VoiceRanges -> [Pitch]

-- | Adjust a whole <a>Voice</a> stepwise
stepwiseVoiceInRange :: Voice -> VoiceRanges -> Voice

-- | Go through list of pitches and reduce intervals that are more than a
--   seventh
stepwise :: [Pitch] -> [Pitch]

-- | Adjust a whole <a>Voice</a> stepwise
stepwiseVoice :: Voice -> Voice

-- | Reduce leap of more than a seventh by shifting octave of second note
--   up or down until the interval is within range
--   
--   <b>TODO</b> : - but what if after adjusting for leaps, a note is out
--   of range? - and what if there is a descending scale that goes out of
--   range and the only way to adjust it is to make a seventh? need to
--   adjust a whole phrase
unleap :: Pitch -> Pitch -> Pitch

-- | Safe list indexing
(!!?) :: [a] -> Int -> Maybe a

-- | Return the highest pitch in a list of pitches.
pitchMax :: [Pitch] -> Maybe Pitch

-- | Return the lowest pitch in a list of pitches.
pitchMin :: [Pitch] -> Maybe Pitch

-- | TODO write your own max/min functions for pitches that ignore Rests
--   
--   Adjust a whole <a>Voice</a> to be in range: check the highest and
--   lowest notes in the list, compare to the range for the voice, and
--   shift the whole thing by octave until all are in range; return error
--   if it can't be done
voiceInRange :: Voice -> VoiceRanges -> Voice

-- | Central functions of the ark: given all parameters required by Kircher
--   (style, meter, syllable count, penultimate syllable length), select a
--   voice permutation (Kircher's number tables) from the appropriate part
--   of the ark and match it to a rhythm permutation (his tables of note
--   values).
--   
--   Return a <a>Voice</a> with the pitches for a single voice part.
--   
--   We use <a>getVoice</a> and <a>getRperm</a> from the <tt>Aedifico</tt>
--   module.
--   
--   Because the rhythms can include rest, we have to match up pitches and
--   rhythms accordingly using <a>zipFill</a> with the test <a>isRest</a>.
ark2voice :: Arca -> ArkConfig -> PenultLength -> Int -> Int -> VoiceName -> Perm -> Voice

-- | A <a>Note</a> contains a pitch and a syllable, equivalent to MEI
--   <tt>note</tt>
data Note
Note :: Pitch -> Syllable -> Note
[notePitch] :: Note -> Pitch
[noteSyllable] :: Note -> Syllable

-- | A <a>Syllable</a> is a single syllable to be paired with a
--   <a>Pitch</a>, including its position in the word.
data Syllable
Syllable :: String -> SyllablePosition -> Syllable
[sylText] :: Syllable -> String
[sylPosition] :: Syllable -> SyllablePosition

-- | What is the position of the syllable relative to the word? Beginning,
--   middle, or end? This determines hyphenation.
data SyllablePosition
First :: SyllablePosition
Middle :: SyllablePosition
Last :: SyllablePosition
Only :: SyllablePosition

-- | no syllable
Tacet :: SyllablePosition

-- | A <a>MusicPhrase</a> contains all the notes set using one permutation
--   drawn from the ark, for a single voice.
data MusicPhrase
MusicPhrase :: VoiceName -> [Note] -> MusicPhrase
[phraseVoiceID] :: MusicPhrase -> VoiceName
[notes] :: MusicPhrase -> [Note]

-- | A list of <a>MusicPhrase</a> items
type MusicSentence = [MusicPhrase]

-- | A <a>MusicSection</a> contains all the music for one section in the
--   input XML document, for a single voice, together with the parameters
--   set in the input file.
data MusicSection
MusicSection :: VoiceName -> ArkConfig -> [MusicSentence] -> MusicSection
[secVoiceID] :: MusicSection -> VoiceName
[secConfig] :: MusicSection -> ArkConfig
[secSentences] :: MusicSection -> [MusicSentence]

-- | A <a>MusicChorus</a> is a four-voice SATB structure of
--   <a>MusicSection</a> data. <b>TODO</b> do we really need it to be
--   structured this way?
data MusicChorus
MusicChorus :: MusicSection -> MusicSection -> MusicSection -> MusicSection -> MusicChorus
[soprano] :: MusicChorus -> MusicSection
[alto] :: MusicChorus -> MusicSection
[tenor] :: MusicChorus -> MusicSection
[bass] :: MusicChorus -> MusicSection

-- | The full <a>MusicScore</a> is a list of SATB <a>MusicChorus</a>
--   structures.
type MusicScore = [MusicChorus]

-- | Take a <a>Verbum</a> read from the input file and turn it into a list
--   of <a>Syllable</a>s for storage in <a>Note</a>s. Record the syllable's
--   position within the word.
makeSyllables :: Verbum -> [Syllable]

-- | Just a blank syllable for filler when needed
blankSyllable :: Syllable

-- | Compose the music for a whole <a>LyricPhrase</a> with one permutation
--   from the ark, and package it into a <a>MusicPhrase</a>. Note that this
--   is for a single voice only, not the four SATB voices. Line up pitches
--   and syllables, skipping rests. In Syntagma I, line up text and notes
--   syllabically (one syllable per note); in syntagma II (florid), lump
--   the text into a single syllable and put it as an incipit text at the
--   beginning of the phrase. (See module description for why Kircher's
--   specification makes this is necessary.)
makeMusicPhrase :: Arca -> ArkConfig -> VoiceName -> LyricPhrase -> Perm -> MusicPhrase

-- | Compose music for a <a>LyricSentence</a> for a single voice.
makeMusicSentence :: Arca -> ArkConfig -> VoiceName -> LyricSentence -> SentencePerm -> MusicSentence

-- | Compose music for all four SATB voices for one <a>LyricSection</a>.
makeMusicChorus :: Arca -> LyricSection -> SectionPerm -> MusicChorus

-- | Put together all the music information for one <a>LyricSection</a>,
--   for a single voice.
--   
--   <ul>
--   <li>For a single voice:<ul><li>extract ArkConfig for whole
--   section</li><li>for each sentence in section:<ul><li>extract list of
--   perms, one per phrase</li><li>extract list of lyric
--   phrases</li><li>apply same ArkConfig</li></ul></li><li>for each phrase
--   in sentence:<ul><li>look up vperm according to config and
--   perm<ul><li>(for some pinakes, choose column by stanza = section
--   num)</li></ul></li><li>look up rperm according to config and
--   perm<ul><li>(for syntagma II, use same perm)</li></ul></li><li>convert
--   vperm nums to pitch names</li><li>(adjust pitches)</li><li>make
--   Pitches: match pitches and rhythms, accounting for rests</li><li>match
--   Notes: match each Pitch with Phrase<i>Verbum</i>Syllable according to
--   syntagma</li><li>return a MusicPhrase</li></ul></li><li>inside a
--   MusicSentence</li></ul></li>
--   <li>inside a MusicSection</li>
--   </ul>
makeMusicSection :: Arca -> LyricSection -> SectionPerm -> VoiceName -> MusicSection

-- | Compose the music for the whole document as a <a>MusicScore</a>,
--   pulling the data from the <a>Arca</a>.
makeMusicScore :: Arca -> [LyricSection] -> [SectionPerm] -> MusicScore

-- | Get music data for all four voices and pack them into a <a>Chorus</a>.
--   
--   <b>TODO</b>: Why do we use a <tt>Fortuna</tt> <a>Perm</a> here but
--   just two integers in the preceding function? Do we need to have all
--   these parameters for both of these functions?
--   
--   We should be getting a new <a>Perm</a> for each Chorus.
getChorus :: Arca -> ArkConfig -> LyricPhrase -> Perm -> Chorus

-- | Set the starting note of a voice to be within the proper range
setVoiceInitialRange :: Voice -> VoiceRanges -> Voice

-- | A <a>Symphonia</a> is the amalgamation of a list of <a>Chorus</a>es
--   into one <a>Chorus</a>
data Symphonia
Symphonia :: Chorus -> LyricSection -> Symphonia
[chorus] :: Symphonia -> Chorus
[lyricSection] :: Symphonia -> LyricSection

-- | Turn <tt>[[S, A, T, B], [S1, A1, T1, B1]]</tt> into <tt>[[S, S1], [A,
--   A1], [T, T1], [B, B1]]</tt>
mergeChoruses :: [Chorus] -> Chorus

-- | To make a <a>Symphonia</a> we take a <a>LyricSentence</a> and list of
--   <a>Perm</a>s, use <a>getChorus</a> to get the ark data for each
--   <a>LyricPhrase</a> in the sentence, each using its own <a>Perm</a>;
--   then we use <a>transpose</a> to reorder the lists.
--   
--   Where we had <tt>[[S1, A1, T1, B1], [S2, A2, T2, B2], [S3, A3, T3,
--   B3]]</tt> we end with <tt>[[S1, S2, S3], [A1, A2, A3], [T1, T2, T3],
--   [B1, B2, B3]]</tt>. A list of four voices becomes four lists of
--   voices. We need to combine each of those voices into a single voice to
--   have a list of four (longer) voices.
--   
--   Adjust music of merged voices to avoid bad intervals
--   (<a>stepwise</a>).
--   
--   The <tt>Scribo</tt> module calls this function to get all the ark data
--   needed to set a whole <a>LyricSentence</a>, in the central function of
--   our implementation, <tt>Scribo.compose</tt>.
getSymphonia :: Arca -> LyricSection -> SectionPerm -> Symphonia

-- | Get all the music for the sections from input
getMasterMusic :: Arca -> [LyricSection] -> [SectionPerm] -> [Symphonia]
instance GHC.Classes.Ord Cogito.MusicPhrase
instance GHC.Classes.Eq Cogito.MusicPhrase
instance GHC.Show.Show Cogito.MusicPhrase
instance GHC.Classes.Ord Cogito.Note
instance GHC.Classes.Eq Cogito.Note
instance GHC.Show.Show Cogito.Note
instance GHC.Classes.Ord Cogito.Syllable
instance GHC.Classes.Eq Cogito.Syllable
instance GHC.Show.Show Cogito.Syllable
instance GHC.Classes.Ord Cogito.SyllablePosition
instance GHC.Classes.Eq Cogito.SyllablePosition
instance GHC.Enum.Enum Cogito.SyllablePosition
instance GHC.Show.Show Cogito.SyllablePosition
instance GHC.Classes.Ord Cogito.Voice
instance GHC.Classes.Eq Cogito.Voice
instance GHC.Show.Show Cogito.Voice
instance GHC.Classes.Ord Cogito.RawPitch
instance GHC.Classes.Eq Cogito.RawPitch
instance GHC.Show.Show Cogito.RawPitch


-- | This module is our implementation of Kircher's <i>palimpsest
--   phonotacticum</i>, his system for writing out the music created using
--   the ark. Certain elements that Kircher used notation to calculate
--   (like determining vocal ranges by clef combinations and the size of
--   the staff) we actually do in the <tt>Cogito</tt> module. This module
--   is purely focused on output of complete music information to a
--   music-notation language.
--   
--   This module outputs to Lilypond, which could then be processed by that
--   program to PDF, MIDI, or other formats.
--   
--   This module also contains the central <a>compose</a> function that
--   takes in a text processed by the <tt>Lectio</tt> module, and does the
--   rest of the work of getting data from the ark, adjusting and
--   translating that data into music (using <tt>Cogito</tt>), and then
--   writing it.
module Scribo.Lilypond

-- | Write pitch as Lilypond music note. Look up needed string values for
--   letter name, accidental, octave tick marks, and duration in lists
--   based on data in given <a>Pitch</a>. If it is a <a>Rest</a>, just
--   print the rest rhythm string.
--   
--   Most of these just require using an enum value as index to a list of
--   strings or characters. The octave requires us to calculate the number
--   of commas or apostrophes to add (relative to Helmholtz octave 3 =
--   <tt>c</tt>).
pitch2ly :: Pitch -> String

-- | Put things inside enclosing parens, brackets, etc.
enbrace :: String -> String -> String -> String

-- | Group string in curly braces <tt>{string}</tt> with added newlines
lyMusicGroup :: String -> String

-- | Group string in double angle brackets <tt>&lt;&lt;string&gt;&gt;</tt>
--   with added newlines
lySimultaneousGroup :: String -> String

-- | Write a <a>Voice</a> to a Lilypond music group:
--   
--   <pre>
--   \new Staff&lt;&lt; \new Voice { ... } &gt;&gt;
--   </pre>
--   
--   We have to include Lilypond <tt>midiInstrument</tt> here.
voice2ly :: Voice -> ModeSystem -> LyricSection -> String

-- | Write a <a>LyricSection</a> to a Lilypond <tt>new Lyrics { }</tt>
--   statement for a particular voice (<tt>VoiceName</tt>). Separate --
--   syllables with <tt> -- </tt>.
lyrics2ly :: LyricSection -> Voice -> String

-- | The opening string per voice
voice2lyOpening :: Voice -> String

-- | The end of the music part of the voice and beginning of the lyrics
voice2lyClosing :: Voice -> String

-- | The end of the voice and its lyrics (discards input)
voiceClosing :: Voice -> String

-- | Convert all the music derived from input into notation output
masterMusic2ly :: Arca -> [Symphonia] -> String

-- | Make Lilypond preamble of include commands
makePreamble :: [String] -> String

-- | Make Lilypond header with the Arca as the author
makeHeader :: ArkMetadata -> String

-- | Set a prepared <a>LyricSentence</a> to music in one go. Return the
--   text of a complete Lilypond file as a string. Write version number and
--   preamble, and put music into <tt>score</tt> and <tt>StaffGroup</tt>
--   (needed because we are doing <i>Mensurstriche</i>).
compose :: Arca -> ArkMetadata -> [LyricSection] -> [SectionPerm] -> String


-- | This module is our implementation of Kircher's <i>palimpsest
--   phonotacticum</i>, his system for writing out the music created using
--   the ark. Certain elements that Kircher used notation to calculate
--   (like determining vocal ranges by clef combinations and the size of
--   the staff) we actually do in the <tt>Cogito</tt> module. This module
--   is purely focused on output of complete music information to a
--   music-notation language.
--   
--   This module outputs in the XML format of the Music Encoding Initiative
--   (MEI).
--   
--   This means that the whole arca program is transforming an input XML
--   document with the text and parameters into and output XML document
--   with the text matched to music.
module Scribo.MEI

-- | Put a string between two other strings
enbrace :: String -> String -> String -> String

-- | Create an XML opening tag, e.g., <tt><a>p</a></tt>
xmltagOpen :: String -> String

-- | Create an XML closing tag, e.g., <tt><a>/p</a></tt>
xmltagClose :: String -> String

-- | Put something between opening and closing XML tags, specifying text of
--   opening tag, contents, and closing tag: &gt; xmlWrap "p" "text" "p"
--   =&gt; <a>p</a>text<a>/p</a>
xmlWrap :: String -> [String] -> String -> String

-- | Put something between XML tags, with the same text for opening and
--   closing: &gt; xmlWrapBasic "p" "text" =&gt; <a>p</a>text<a>/p</a>
xmlWrapBasic :: String -> [String] -> String

-- | Create an XML element (which may contain other elements). If you need
--   attributes, use <a>elementAttr</a>.
element :: String -> [String] -> String

-- | Create an XML attribute
attr :: String -> String -> String

-- | Create an XML element that has attributes, e.g.,
--   <tt><a>class="foo"</a>bar<a>/p</a></tt>
elementAttr :: String -> [String] -> [String] -> String

-- | Create an MEI <tt>note</tt> element from our <tt>Note</tt> datatype,
--   converting the attributes as needed. If the <tt>Note</tt> actually
--   contains a rest (<a>Pitch</a> with only a <a>Dur</a> in the rest
--   range), then produce a <tt>rest</tt> element.
note2mei :: Note -> String

-- | Convert <a>Pnum</a> to MEI <tt>pname</tt>
meiPname :: Pitch -> String

-- | Just print the octave number
meiOct :: Pitch -> String

-- | Convert <a>Dur</a> to MEI <tt>dur</tt> (base value of duration) and
--   @dots (if any; omit if not)
meiDur :: Pitch -> String

-- | Convert our <a>Accid</a> to MEI <tt>accid</tt> (omit if natural)
--   
--   <b>TODO</b> Verovio will display the accidental if the <tt>accid</tt>
--   attribute or element is present, regardless of the key signature. We
--   would need to check the mode/key and then use accid.ges for
--   accidentals that are in the key signature.
meiAccid :: Pitch -> String

-- | If a word is a single syllable, we do not need to include
--   <tt>@con</tt> or <tt>@wordpos</tt>; if it is more than one syllable,
--   we include these attributes. We use a dash connector by default, and
--   get the word position from the data in the <a>Syllable</a> type.
meiSyllable :: Syllable -> String

-- | Where is this item in the list that contains it?
data ListPosition

-- | head of list
ListHead :: ListPosition

-- | neither head nor last
ListBody :: ListPosition

-- | last item in list
ListEnd :: ListPosition

-- | only item of a one-item list
ListOnly :: ListPosition

-- | Given a function that takes a ListPosition argument and a list, apply
--   the function to the list. This allows you to treat the first and last
--   items in the list differently.
positionMap :: ((ListPosition, a1) -> [a2]) -> [a1] -> [a2]

-- | Mark a list with the positions of the items: first, body, and last.
--   Output a list of pairs with the <a>ListPosition</a> and the original
--   list item.
markedEnds :: [a] -> [(ListPosition, a)]

-- | Make an XML string containing a list of <tt>note</tt> elements out of
--   a <a>MusicPhrase</a>; end each phrase with <tt>barline</tt>, except
--   for last in the list.
--   
--   Leave the barline of the last phrase up to the next-higher function
--   (end of sentence gets regular bar; end of sentence, double bar; end of
--   section, final bar).
phrase2mei :: (ListPosition, MusicPhrase) -> String

-- | Make an XML string containing all the contents of one <tt>layer</tt>
--   out of a <a>MusicSentence</a>. If this is the last sentence in the
--   section, omit the bar so the higher function calling this one can add
--   it. Sentence ends with regular barline.
sentence2mei :: (ListPosition, MusicSentence) -> String

-- | A <a>MusicSection</a> contains all the music for one section, /for a
--   single voice/: so combine all subdivisions into one <tt>staff</tt> and
--   <tt>layer</tt> so this can be made part of an MEI <tt>section</tt> in
--   <a>chorus2mei</a>. Include MEI 1-indexed staff number derived from
--   <a>VoiceName</a> enum Put a double bar at the end of sections and a
--   final bar at the end of the piece.
--   
--   <b> TODO </b> you could put more than one layer per staff if you
--   wanted a 2-staff choirstaff (e.g., SA on one, TB on the other)
section2mei :: Arca -> (ListPosition, MusicSection) -> String

-- | Take a list of sections, one per SATB voice, and create a single MEI
--   <tt>section</tt> including all the voices. Add a final bar at the end.
chorus2mei :: Arca -> (ListPosition, MusicChorus) -> String

-- | Create an MEI key signature (all naturals or one flat) based on mode
--   (<tt>key.sig</tt> attribute for use in
--   <tt>scoreDef</tt>/<tt>staffDef</tt>)
meiKey :: Mode -> ModeSystem -> String

-- | MEI key signature as an attribute (for use in <tt>staffDef</tt>)
meiKeyAttr :: Mode -> ModeSystem -> String

-- | Value for MEI <tt>key.sig</tt>: one flat if mode is <i>mollis</i>, no
--   signature otherwise
meiKeySigString :: Mode -> ModeSystem -> String

-- | Switch to select which kind of meter to use as an element
meiMeter :: MusicMeter -> String

-- | Switch to select which kind of meter to use as an attribute
meiMeterAttr :: MusicMeter -> String

-- | Create an MEI meter signature (using modern equivalents of Kircher's
--   C, C3, cutC3). (<tt>meterSig with </tt>meter.count<tt> and
--   </tt>meter.unit<tt> attributes for use in
--   </tt>scoreDef<tt>/</tt>staffDef@)
meiMeterModern :: MusicMeter -> String

-- | Mensural version of <a>meiMeter</a>. We want either <a>C</a>,
--   <a>C3</a>, or "cutC3". Verovio does not render these correctly as of
--   2021/07 when using the <tt>proport</tt> element (or
--   <tt>proport.num</tt> attribute) for the number, which is the correct
--   encoding. But putting <tt>num</tt> directly inside <tt>mensur</tt>
--   works with Verovio.
meiMeterMensural :: MusicMeter -> String

-- | Mensural meter with proportion as a string of attributes (for use in
--   <tt>staffDef</tt>, where the correct encoding also works with
--   Verovio).
meiMeterMensuralAttr :: MusicMeter -> String

-- | Extract a simple list of <a>MusicSentence</a> from the four members of
--   a <a>MusicChorus</a>
chorus2list :: MusicChorus -> [MusicSection]

-- | Convert a whole <a>MusicScore</a> to MEI XML. Include meter and key of
--   first section in top-level <tt>scoreDef</tt> (<b>TODO</b> ?) Pass on
--   the position in the list to the next function down.
score2mei :: Arca -> ArkMetadata -> MusicScore -> String

-- | Make an MEI double barline
meiDoubleBar :: String

-- | Make an MEI final barline
meiFinalBar :: String

-- | Make an MEI <tt>barLine</tt> element
meiBarline :: String -> String

-- | Default XML header
_xmlHeader :: [Char]

-- | MEI version number
_meiVersion :: [Char]

-- | The "composer" (that is, the ark itself)
_whoami :: [Char]

-- | The "inventor"
_Kircher :: [Char]

-- | The "programmer" and "text preparer"
_AAC :: [Char]

-- | MEI project description text
_projectDesc :: [Char]

-- | MIDI tempo
_midiBPM :: [Char]

-- | MIDI instrument
_midiInstrument :: String

-- | Plug in variables and musical content needed to boilerplate MEI
--   document in all its baroque verbosity
meiDocument :: String -> String -> String -> String -> String -> String
instance GHC.Classes.Eq Scribo.MEI.ListPosition
instance GHC.Show.Show Scribo.MEI.ListPosition
instance GHC.Enum.Enum Scribo.MEI.ListPosition
