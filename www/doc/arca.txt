-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Bitbucket at
--   <a>https://bitbucket.org/andrewacashner/kircher/src/master/arca/README.md</a>.
--   The arca web app is at <a>http://www.arca1650.info</a>.
@package arca
@version 0.1.0.0


-- | This module provides the data structures and methods for storing the
--   data of Kircher's ark and then extracting it. (*aedifico* = Latin, "I
--   build") The <tt>Arca_musarithmica</tt> module actually builds it.
--   
--   <h1>Kircher's specification</h1>
--   
--   As described in Kircher's <i>Musurgia universalis</i> (Rome, 1650),
--   book 8, the ark is a box containing rods (<i>pinakes</i>), each of
--   which includes columns with voice and rhythm permutations. The rods
--   are grouped according to style into <i>syntagmata</i>, where
--   <i>syntagma</i> 1 is simple homorhythmic counterpoint. There are two
--   surviving exemplars of physical implementations of the ark.
--   
--   The top part of Kircher's "rods" contain tables table of numbers with
--   four rows, where the numbers represent pitch offsets from a modal base
--   note, and the rows are the notes for the four voice parts SATB. Each
--   table represents the notes to set a single phrase of text with a given
--   number of syllables.
--   
--   <h1>Implementation</h1>
--   
--   This module implements analogous data structures using Haskell types
--   and defines methods for building the ark from input data, and for
--   accessing each element of the ark data.
--   
--   It also defines the data types needed for the other modules.
--   
--   <h2>Structure of the ark in Haskell implementation (simplified)</h2>
--   
--   <pre>
--   Arca
--       vperms
--           Arca                     = Vector (Syntagma)
--           Syntagma                 = Vector (Pinax)
--           Pinax                    = Vector (Column)
--           Column { colVpermTable } = VpermTable
--           VpermTable { vperms }    = Vector (VpermChoir)
--           VpermChoir               = Vector (Vperm)
--           Vperm                    = [Int]
--   
--       rperms
--           Arca                     = Vector (Syntagma)
--           Syntagma                 = Vector (Pinax)
--           Pinax                    = Vector (Column)
--           Column { colRpermTable } = RpermTable
--           RpermTable               = Vector (RpermMeter)
--           RpermMeter { rperms }    = Vector (RpermChoir)
--           RpermChoir               = Vector (Rperm)
--           Rperm                    = [Dur]
--   </pre>
--   
--   <h3>Accessing perms directly</h3>
--   
--   The test module <tt>Spec.hs</tt> shows how to access all of the ark
--   data directly. These notes might clarify how to reach individual ark
--   vperms or rperms.
--   
--   <pre>
--   vperms
--        perms arca          :: Vector (Vector (Vector Column))
--        colVpermTable       :: VpermTable
--        vperms vpermTable   :: Vector (Vector [Int])
--   
--        vperm :: [Int]
--        vperm = vperms table ! vpermIndex ! voiceIndex
--        where
--            table  = colVpermTable $ column ! columnIndex
--            column = perms arca ! syntagmaIndex ! pinaxIndex ! columnIndex
--   
--   rperms
--        rperm :: [Dur]
--        rperm = rperms table ! rpermMeterIndex ! rpermVoiceIndex
--        where
--            table  = colVpermTable $ column ! columnIndex
--            column = perms arca ! syntagmaIndex ! pinaxIndex ! columnIndex
--   </pre>
module Aedifico

-- | Safe list indexing
(!!?) :: [a] -> Int -> Maybe a

-- | Pitches
--   
--   The <a>Pnum</a> is a 0-indexed diatonic pitch-class number, C through
--   C an octave higher. (In Kircher's 1-indexed system he uses both 1 and
--   8 for C so we must be able to tell the difference.)
data Pnum
PCc :: Pnum
PCd :: Pnum
PCe :: Pnum
PCf :: Pnum
PCg :: Pnum
PCa :: Pnum
PCb :: Pnum

-- | C an octave higher
PCc8 :: Pnum
Rest :: Pnum

-- | Convert any integer to a <a>Pnum</a>
toPnum :: Int -> Pnum

-- | Accidentals
data Accid

-- | flat
Fl :: Accid

-- | natural
Na :: Accid

-- | sharp
Sh :: Accid

-- | when note is a rest
AccidNil :: Accid

-- | Octaves
--   
--   We set octave numbers in the Helmholtz system (middle C = C4); we only
--   need the enum <a>OctNil</a> if the note is a rest.
--   
--   <b>TODO</b> check
data Octave
OctNil :: Octave

-- | Voices
--   
--   The ark always produces four-voice polyphony.
data VoiceName
Soprano :: VoiceName
Alto :: VoiceName
Tenor :: VoiceName
Bass :: VoiceName

-- | Vocal Ranges
data VoiceRange
VoiceRange :: Pitch -> Pitch -> VoiceRange
[low] :: VoiceRange -> Pitch
[high] :: VoiceRange -> Pitch

-- | Set of <a>VoiceRange</a> data for each <a>VoiceName</a>
data VoiceRanges
VoiceRanges :: VoiceRange -> VoiceRange -> VoiceRange -> VoiceRange -> VoiceRanges
[sopranoRange] :: VoiceRanges -> VoiceRange
[altoRange] :: VoiceRanges -> VoiceRange
[tenorRange] :: VoiceRanges -> VoiceRange
[bassRange] :: VoiceRanges -> VoiceRange

-- | Access data from <a>VoiceRanges</a> by <a>VoiceName</a>
getRange :: VoiceName -> VoiceRanges -> VoiceRange

-- | Duration values
--   
--   We use the mensural names; first the base values, then dotted
--   variants, then a series marked as rest values.
data Dur

-- | unset
DurNil :: Dur

-- | longa
Lg :: Dur

-- | breve
Br :: Dur

-- | semibreve
Sb :: Dur

-- | minim
Mn :: Dur

-- | semiminim
Sm :: Dur

-- | fusa
Fs :: Dur

-- | dotted longa
LgD :: Dur

-- | dotted breve
BrD :: Dur

-- | dotted semibreve
SbD :: Dur

-- | dotted minim
MnD :: Dur

-- | dotted semiminim
SmD :: Dur

-- | dotted fusa
FsD :: Dur

-- | longa rest
LgR :: Dur

-- | breve rest
BrR :: Dur

-- | semibreve rest
SbR :: Dur

-- | minim rest
MnR :: Dur

-- | semiminim rest
SmR :: Dur

-- | fusa rest
FsR :: Dur

-- | How should the accidental be displayed? (Needed for MEI)
data AccidType

-- | No accidental
None :: AccidType

-- | MEI accid
Written :: AccidType

-- | MEI accid.ges
Implicit :: AccidType

-- | MEI accid + func="edit"
Suggested :: AccidType

-- | A <a>Pitch</a> stores the essential information for notating a single
--   note.
data Pitch
Pitch :: Pnum -> Int -> Dur -> Accid -> AccidType -> Pitch

-- | Enum for diatonic pitch number
[pnum] :: Pitch -> Pnum

-- | Helmholtz system, middle C = 4
[oct] :: Pitch -> Int

-- | Duration, one of <tt>Dur</tt> enum
[dur] :: Pitch -> Dur

-- | Accidental
[accid] :: Pitch -> Accid

-- | Type of accidental for display
[accidType] :: Pitch -> AccidType

-- | Make a pitch with only <a>pnum</a> and octave, no duration or
--   accidental
simplePitch :: (Pnum, Int) -> Pitch

-- | Kircher only seems to allow for duple (not making distinction between
--   C and cut C), cut C 3 (triple major) and C3 (triple minor).
--   
--   <b>TODO</b> Should we distinguish between C and cut C duple?
data MusicMeter
Duple :: MusicMeter
TripleMajor :: MusicMeter
TripleMinor :: MusicMeter

-- | Select meter by string
toMusicMeter :: String -> MusicMeter

-- | Text meter (of input text, distinguished from musical meter of
--   setting)
data TextMeter
TextMeterNil :: TextMeter

-- | No meter, free, or irregular
Prose :: TextMeter

-- | Prose, 2-6 syllabels, penultimate is long
ProseLong :: TextMeter

-- | Prose, 2-6 syllables, penultimate is short
ProseShort :: TextMeter

-- | 5 syllables (<tt>`--`-</tt>)
Adonium :: TextMeter

-- | 6 syllables (<tt>`--`--</tt>)
Dactylicum :: TextMeter

-- | 6 syllables (<tt><a>-</a>-`-</tt>)
IambicumEuripidaeum :: TextMeter

-- | 7 syllables, penultimate long
Anacreonticum :: TextMeter

-- | 8 syllables, penultimate short
IambicumArchilochicum :: TextMeter

-- | 9 syllables, penultimate long
IambicumEnneasyllabicum :: TextMeter

-- | 9 syllables (generic)
Enneasyllabicum :: TextMeter

-- | 10 syllables, penultimate short
Decasyllabicum :: TextMeter

-- | 11 syllables
PhaleuciumHendecasyllabicum :: TextMeter

-- | 11 syllables (generic)
Hendecasyllabicum :: TextMeter

-- | 11 syllables, three lines + 5-syllable tag
Sapphicum :: TextMeter

-- | 12 syllables, penultimate short
Dodecasyllabicum :: TextMeter

-- | Select text meter by string
toTextMeter :: String -> TextMeter

-- | Get maximum number of syllables for a TextMeter
maxSyllables :: TextMeter -> Int

-- | The choice of style determines which of Kircher's three
--   <i>syntagmata</i> we select. <a>Simple</a> style calls up Syntagma 1
--   for simple, note-against-note (first-species) homorhythmic
--   counterpoint. <a>Florid</a> style calls up Syntagma 2 for syllabic,
--   imitative, and even in some permutations fugal counterpoint.
--   
--   <b>TODO</b> There is also a third syntagma, for adding rhetorical
--   figures to simple counterpoint for more nuanced text-setting. We have
--   not yet implemented this, and do not know if it can be fully
--   automated.
data Style

-- | Syllabic, homorhythmic counterpoint (syntagma 1)
Simple :: Style

-- | Melismatic, imitative counterpoint (syntagma 2)
Florid :: Style

-- | Select style by string (used in processing XML input)
toStyle :: String -> Style

-- | Tone
--   
--   Kircher's table of tones is a hybrid of <i>toni ecclesiastici</i> or
--   "church keys" which were matched to the eight traditional psalm tones
--   in Gregorian chant, and the twelve modes of Zarlino.
data Tone
Tone1 :: Tone
Tone2 :: Tone
Tone3 :: Tone
Tone4 :: Tone
Tone5 :: Tone
Tone6 :: Tone
Tone7 :: Tone
Tone8 :: Tone
Tone9 :: Tone
Tone10 :: Tone
Tone11 :: Tone
Tone12 :: Tone
ToneUnset :: Tone

-- | Select tone by string (e.g., <a>Tone1</a> or <a>Tone12</a> in XML
--   input)
toTone :: String -> Tone

-- | Tone system, <i>durus</i> (natural) or <i>mollis</i> (one flat in the
--   key signature)
data System
Durus :: System
Mollis :: System

-- | The series of <a>System</a> values for the tones
type ToneSystem = Vector (System)

-- | Combination <a>Pnum</a> and <a>Accid</a> used to set a Pitch
type PnumAccid = (Pnum, Accid)

-- | A list of scales, including some notes with accidentals, from Kircher
type ToneList = Vector (Vector PnumAccid)

-- | List of tones appropriate for each pinax within each syntagma (style):
--   association list mapping style to sets of <i>pinakes</i>, and then
--   <i>pinakes</i> to tones
type PinaxLegalTones = AssocList PinaxLabel [[Tone]]
type PinaxToneList = AssocList Style PinaxLegalTones

-- | Lookup a value by equality in an association list, or raise an error
--   if not found
assocLookup :: Eq a => a -> AssocList a b -> String -> b

-- | Get a list of legal tones for a given <a>Style</a> and
--   <a>PinaxLabel</a>
tonesPerStyle :: Style -> PinaxLabel -> PinaxToneList -> [[Tone]]

-- | Penultimate Syllable Length
--   
--   Every unit of text to be set to music must be marked with either a
--   long or short penultimate syllable.
data PenultLength
Long :: PenultLength
Short :: PenultLength

-- | <a>Pinax</a> maps to <a>TextMeter</a>
data PinaxLabel
Pinax1 :: PinaxLabel
Pinax2 :: PinaxLabel
Pinax3 :: PinaxLabel
Pinax3a :: PinaxLabel
Pinax3b :: PinaxLabel
Pinax4 :: PinaxLabel
Pinax5 :: PinaxLabel
Pinax6 :: PinaxLabel
Pinax7 :: PinaxLabel
Pinax8 :: PinaxLabel
Pinax9 :: PinaxLabel
Pinax10 :: PinaxLabel
Pinax11 :: PinaxLabel
PinaxNil :: PinaxLabel
arca2pinax :: Arca -> Style -> PinaxLabel -> Pinax

-- | Get pinax from textual meter; this depends on the <a>Style</a> because
--   the <i>syntagmata</i> differ in the order of meters, so
--   <a>IambicumEuripidaeum</a> meter in Syntagma 1 is <a>Pinax4</a>, but
--   in Syntagma 2 it is <a>Pinax2</a>.
meter2pinax :: Style -> TextMeter -> PinaxLabel

-- | Is this tone acceptable to use for this pinax in this syntagma, for
--   this line number ("stropha")?
isToneLegalInPinax :: PinaxToneList -> Style -> PinaxLabel -> Int -> Tone -> Bool

-- | In prose, determine <a>TextMeter</a> based on penultimate syllable
--   length
proseMeter :: PenultLength -> TextMeter

-- | All the ark settings in one structure: We use this to pass
--   configuration settings through many functions down to the core level
--   of pulling data from the ark.
data ArkConfig
ArkConfig :: Style -> Tone -> Tone -> MusicMeter -> TextMeter -> ArkConfig
[arkStyle] :: ArkConfig -> Style
[arkTone] :: ArkConfig -> Tone

-- | optional second tone (only used in syntagma 2, pinax 4)
[arkToneB] :: ArkConfig -> Tone
[arkMusicMeter] :: ArkConfig -> MusicMeter
[arkTextMeter] :: ArkConfig -> TextMeter

-- | The top part of Kircher's "rods" contain tables table of numbers with
--   four rows, where the numbers represent pitch offsets from a modal base
--   note, and the rows are the notes for the four voice parts SATB. Each
--   table represents the notes to set a single phrase of text with a given
--   number of syllables.
--   
--   We implement the notes for one voice as a <a>Vperm</a>, a list of
--   <a>Int</a> values.
type Vperm = [Int]

-- | A vector of four <a>Vperm</a>s makes a <a>VpermChoir</a>.
type VpermChoir = Vector (Vperm)

-- | A Vector of <a>VpermChoir</a>s is a <a>VpermTable</a>, which
--   represents the top part of Kircher's "rods". We need to know the
--   vector length because it varies in different <i>pinakes</i>.
data VpermTable
VpermTable :: Int -> Vector VpermChoir -> VpermTable

-- | length of <a>vperms</a>
[vpermMax] :: VpermTable -> Int
[vperms] :: VpermTable -> Vector VpermChoir

-- | The bottom part of the "rods" contain tables of rhythmic values
--   written with musical notes. In the simple note-against-note style,
--   there is one list of values to match each table of voices.
--   
--   We implement this using our <a>Dur</a> data type for the rhythmic
--   values. An <a>Rperm</a> is a list of <a>Dur</a> values.
type Rperm = [Dur]

-- | In Syntagma I, there is only one set of rhythmic permutation that we
--   apply to all four voices of the <a>VpermChoir</a>. But in Syntagma II,
--   there are groups of four <a>Rperm</a>s that match up with the four
--   voices. So we make a "choir" as a vector of <a>Rperm</a>s, though in
--   Syntagma I this will always just have a single member.
type RpermChoir = Vector (Rperm)

-- | An <a>RpermMeter</a> includes a vector of <a>RpermChoir</a>s all in
--   one meter (see the <a>MusicMeter</a> data type above) and the length
--   of that vector.
--   
--   Kircher has a variable number of <a>Rperm</a>s in the different
--   meters, in each column, so we need to know how many there are.
--   
--   In Syntagma II everything is duple meter so there is just the one
--   meter.
data RpermMeter
RpermMeter :: Int -> Vector RpermChoir -> RpermMeter

-- | length of <a>rperms</a>
[rpermMax] :: RpermMeter -> Int
[rperms] :: RpermMeter -> Vector RpermChoir

-- | The <a>RpermTable</a> is a vector containing all the rhythmic
--   permutations for one of Kircher's "rods".
--   
--   <b>TODO</b>: This implementation may not be sufficient for the more
--   complex styles where there are different rhythms for the four voices.
--   Also, as noted above, we may need to distinguish duple major and duple
--   minor.
type RpermTable = Vector (RpermMeter)

-- | The ark is a box containing rods (<i>pinakes</i>), each of which
--   includes columns with voice and rhythm permutations. The rods are
--   grouped according to style into <i>syntagmata</i>, where
--   <i>syntagma</i> 1 is simple homorhythmic counterpoint.
--   
--   We implement the <a>Column</a> as a structure with one
--   <a>VpermTable</a> and one <a>RpermTable</a>.
data Column
Column :: VpermTable -> RpermTable -> Column
[colVpermTable] :: Column -> VpermTable
[colRpermTable] :: Column -> RpermTable

-- | A vector of <a>Column</a> instances is a <a>Pinax</a>.
type Pinax = Vector (Column)

-- | A vector of <a>Pinax</a> instances is a <a>Syntagma</a>.
type Syntagma = Vector (Pinax)

-- | A vector of <a>Syntagma</a> instances makes up the full <a>Arca</a>.
data Arca
Arca :: Vector Syntagma -> ToneList -> ToneSystem -> PinaxToneList -> VoiceRanges -> Arca
[perms] :: Arca -> Vector Syntagma
[tones] :: Arca -> ToneList
[systems] :: Arca -> ToneSystem
[pinaxTones] :: Arca -> PinaxToneList
[ranges] :: Arca -> VoiceRanges

-- | Just get a vector value by index, safely (combining <a>fromJust</a>
--   and <a>!?</a>)
getVectorItem :: String -> Vector a -> Int -> a

-- | Getting a <a>Column</a> requires indexing through nested vectors. But
--   because there are two parts of pinax 3 in syntagma 1, we can't just
--   use the pinax label as an enum; we have to look up the number with
--   <tt>syntagma2pinax</tt>.
column :: Arca -> Style -> PinaxLabel -> Int -> Column

-- | Getting a <a>VpermChoir</a> means taking the first of the
--   <a>Column</a> 2-tuple; we select which one using a random number (from
--   <tt>Fortuna</tt> module), though the Inquisition forbids chance
--   operations
vperm :: Column -> Int -> VpermChoir

-- | Getting an <a>RpermChoir</a> means taking data from <a>Column</a>,
--   using the meter and a random index (for Kircher, user's choice)
rperm :: Column -> MusicMeter -> Int -> RpermChoir

-- | The user of Kircher's arca needs only to know the number of syllables
--   in a phrase and whether the penultimate syllable is long or short.
--   Then they must freely (?) choose which table in the column.
--   
--   We go straight to a voice and a rhythm permutation, given all the
--   needed variables and an index. Instead of choosing freely we tempt
--   fate and use a random number.
getVperm :: Arca -> ArkConfig -> Int -> Int -> Int -> VpermChoir

-- | Use <tt>toneB</tt> attribute if needed, otherwise <tt>tone</tt> (We
--   only use <tt>toneB</tt> for florid pinax 4, every third and fourth
--   line!)
toneOrToneB :: ArkConfig -> Int -> Tone

-- | Select the rhythm values for a single phrase from the ark's rhythm
--   permutations (Rperms).
--   
--   In Pinax 9, there is no TripleMinor category of rperms, so we screen
--   that out first.
--   
--   <b>TODO</b>: Using an error, but we could just substitute TripleMajor
--   with a note in the log (if we had a log).
getRperm :: Arca -> ArkConfig -> Int -> Int -> Int -> RpermChoir

-- | The rule for selecting the column index varies depending on the
--   <i>pinax</i>. Pinax 1 and 2 are determined by whether the penultimate
--   syllables is long or short, respectively, and then the column is based
--   on the number of syllables in the phrase.
--   
--   For the other <i>pinaces</i> we are supposed to choose successive
--   columns for each "stropha" (verse line), so here we select based on
--   the position within a quatrain.
--   
--   (TODO Kircher doesn't provide clear guidance about how to deal with
--   poetry that cannot or should not be grouped in quatrains, and neither
--   do we.)
--   
--   There are different rules for each syntagma, hence the need for Style
--   input.
columnIndex :: Style -> TextMeter -> Int -> Int -> Int

-- | Select the pitch numbers for a single voice from one of the ark's
--   pitch permutations (<a>Vperm</a>s).
getVoice :: Arca -> ArkConfig -> Int -> Int -> VoiceName -> Int -> Vperm

-- | Voice permutation data: 1-indexed pitch numbers, sets of four voices
--   each, usually ten sets per column
type VpermTableInput = [[Vperm]]

-- | Rhythm permutation data: <a>Dur</a> values, three sets for different
--   meters, each containing either one set per voice permutation set
--   (<i>syntagma I</i>) or a four-voice set to match (<i>syntagma II</i>)
type RpermTableInput = [[[Rperm]]]

-- | Column data: Pairs of input data for voice and rhythm permutations
type ColumnInput = (VpermTableInput, RpermTableInput)

-- | Pinax data: List of data for columns
type PinaxInput = [ColumnInput]

-- | To build the ark from the data in the <tt>Arca/</tt> directory, we
--   must take a singly nested list and make it into a vector of vectors.
--   This allows for the data to be input and maintained more simply, as a
--   nested list of integers and strings, but then converted to vectors for
--   better performance. The innermost layer stays in list format.
--   
--   <b>TODO</b>: Optimize?
fromList2D :: [[a]] -> Vector (Vector a)

-- | Make a new <a>VpermTable</a> that knows its own length: Application of
--   <a>fromList2D</a> to <a>Vperm</a>
buildVpermTable :: VpermTableInput -> VpermTable

-- | Make a new <a>RpermMeter</a> that knows its own length.
newRpermMeter :: [[Rperm]] -> RpermMeter

-- | Build an <a>RpermTable</a> with <a>RpermMeter</a>s that know their
--   length.
buildRpermTable :: RpermTableInput -> RpermTable

-- | Build a <a>Column</a> directly from input data: two nested lists, one
--   for all the voice permutations in the column and the other for all the
--   rhythm permutations. Because we are manually entering Kircher's data
--   for the ark we do not check for validity here, and there are several
--   variations across the <i>syntagmata</i> and <i>pinakes</i> in how the
--   data is structured.
buildColumn :: ColumnInput -> Column

-- | Build a <a>Pinax</a> from pairs of <a>VpermTable</a> and
--   <a>RpermTable</a> data
buildPinax :: PinaxInput -> Pinax

-- | Build a <a>Syntagma</a> from constructed <a>Pinax</a> items (not from
--   raw input)
buildSyntagma :: [Pinax] -> Syntagma

-- | Pull out a single <a>Column</a> given indices
columnFromArca :: Arca -> Int -> Int -> Int -> Column

-- | Pull out a single <a>Vperm</a>, which is a list of <a>Int</a>
vpermFromArca :: Arca -> Int -> Int -> Int -> Int -> Int -> Vperm

-- | Pull out a single <a>Rperm</a>, which is a list of <a>Dur</a>
rpermFromArca :: Arca -> Int -> Int -> Int -> Int -> Int -> Int -> Rperm
instance GHC.Classes.Ord Aedifico.ArkConfig
instance GHC.Classes.Eq Aedifico.ArkConfig
instance GHC.Classes.Eq Aedifico.PinaxLabel
instance GHC.Classes.Ord Aedifico.PinaxLabel
instance GHC.Show.Show Aedifico.PinaxLabel
instance GHC.Classes.Ord Aedifico.PenultLength
instance GHC.Classes.Eq Aedifico.PenultLength
instance GHC.Enum.Enum Aedifico.PenultLength
instance GHC.Show.Show Aedifico.PenultLength
instance GHC.Classes.Ord Aedifico.System
instance GHC.Classes.Eq Aedifico.System
instance GHC.Enum.Enum Aedifico.System
instance GHC.Classes.Ord Aedifico.Tone
instance GHC.Classes.Eq Aedifico.Tone
instance GHC.Enum.Enum Aedifico.Tone
instance GHC.Show.Show Aedifico.Tone
instance GHC.Classes.Ord Aedifico.Style
instance GHC.Classes.Eq Aedifico.Style
instance GHC.Enum.Enum Aedifico.Style
instance GHC.Show.Show Aedifico.Style
instance GHC.Classes.Ord Aedifico.TextMeter
instance GHC.Classes.Eq Aedifico.TextMeter
instance GHC.Enum.Enum Aedifico.TextMeter
instance GHC.Show.Show Aedifico.TextMeter
instance GHC.Classes.Ord Aedifico.MusicMeter
instance GHC.Classes.Eq Aedifico.MusicMeter
instance GHC.Enum.Enum Aedifico.MusicMeter
instance GHC.Classes.Ord Aedifico.VoiceRange
instance GHC.Classes.Eq Aedifico.VoiceRange
instance GHC.Show.Show Aedifico.VoiceRange
instance GHC.Classes.Ord Aedifico.Pitch
instance GHC.Classes.Eq Aedifico.Pitch
instance GHC.Show.Show Aedifico.Pitch
instance GHC.Classes.Ord Aedifico.AccidType
instance GHC.Classes.Eq Aedifico.AccidType
instance GHC.Show.Show Aedifico.AccidType
instance GHC.Show.Show Aedifico.Dur
instance GHC.Classes.Ord Aedifico.Dur
instance GHC.Classes.Eq Aedifico.Dur
instance GHC.Enum.Enum Aedifico.Dur
instance GHC.Classes.Ord Aedifico.VoiceName
instance GHC.Classes.Eq Aedifico.VoiceName
instance GHC.Enum.Enum Aedifico.VoiceName
instance GHC.Classes.Ord Aedifico.Octave
instance GHC.Classes.Eq Aedifico.Octave
instance GHC.Enum.Enum Aedifico.Octave
instance GHC.Show.Show Aedifico.Octave
instance GHC.Classes.Ord Aedifico.Accid
instance GHC.Classes.Eq Aedifico.Accid
instance GHC.Enum.Enum Aedifico.Accid
instance GHC.Show.Show Aedifico.Accid
instance GHC.Classes.Ord Aedifico.Pnum
instance GHC.Classes.Eq Aedifico.Pnum
instance GHC.Enum.Enum Aedifico.Pnum
instance GHC.Show.Show Aedifico.Pnum
instance GHC.Show.Show Aedifico.ArkConfig
instance GHC.Show.Show Aedifico.MusicMeter
instance GHC.Show.Show Aedifico.VoiceName


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p1</a>) is for phrases with long
--   penultimate syllables. It contains five columns.
--   
--   It may be used with any tone except for IV and V. II and VI are
--   especially recommended.
module Arca_musarithmica.Syntagma1.Pinax01

-- | Pinax 1 (<a>s1p1</a>): We build the <a>Pinax</a> from <a>Column</a>s.
--   
--   "Pinax I. Voces Polysyllabae quae penultimam Longam habent."
--   
--   This one is for phrases with a long penultimate syllable. There are
--   five columns (<tt>c0</tt> ... <tt>c4</tt>). All the columns are a
--   2-tuple of a <a>Vperm</a> and an <a>Rperm</a>.
s1p1 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p2</a>) is for phrases with short
--   penultimate syllables. It contains five columns.
--   
--   It may be used with any tone except IV and V. II and VI are especially
--   recommended.
module Arca_musarithmica.Syntagma1.Pinax02

-- | Pinax 2, for phrases with short penultimate syllables.
--   
--   "Voces polysyllabae, quae penultimam Breuem habet"
s1p2 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p3a</a>) is for poetry in Adonic meter
--   (<tt>`--`-</tt>). It contains four columns, one for each successive
--   verse line ("Kircher's stropha") of a quatrain. There is only one
--   rperm for each side, repeated for each column.
--   
--   It may be used with any tone, especially 2 and 6.
module Arca_musarithmica.Syntagma1.Pinax03a

-- | Pinax 3
s1p3a :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p3b</a>) is for poetry in Dactylic meter
--   (<tt>`--`--</tt>). It contains four columns, one for each successive
--   verse line ("Kircher's stropha") of a quatrain. There is only one
--   rperm for each side, repeated for each column.
--   
--   It may be used with any tone, especially 2 and 6.
module Arca_musarithmica.Syntagma1.Pinax03b

-- | Pinax 3
s1p3b :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s1p4</a>) is for poetry in
--   Iambic-Euripidaeic meter, 6 syllable lines with pattern <a>-</a>-`-.
--   There are four columns, meant to be used in order of each line in a
--   four-line strophe (though each column is confusingly labeled
--   "stropha"). There is only one <a>RpermTable</a> for all four columns.
--   
--   Acceptable tones are I, II, III, IV, IX, and X.
module Arca_musarithmica.Syntagma1.Pinax04

-- | Pinax 4
s1p4 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 85) This <i>pinax</i> (<a>s1p5</a>) is for poetry in
--   Anacreontic meter, 7 syllable lines with long penultimate. What appear
--   to be eight columns are really four, as they correspond with verse
--   lines 1--4 as in <tt>Pinax4</tt>. There is only one <a>RpermTable</a>
--   for all four columns.
--   
--   It may be used with tone I, II, III, IV, IX, and X.
module Arca_musarithmica.Syntagma1.Pinax05

-- | Pinax 5
s1p5 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 87): "Iambica Archilochica octosyllaba penultima
--   breuia". This <i>pinax</i> (<a>s1p6</a>) is for poetry in Iambic
--   meter, 8-syllable lines with short penultimate. There are four
--   columns, one for each successive line (but called "strophes"). There
--   is only one <a>RpermTable</a> for all four columns.
--   
--   It may be used with tone V, VI, VIII, and XII.
module Arca_musarithmica.Syntagma1.Pinax06

-- | Pinax 6
s1p6 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 89): "Iambica Enneasyllaba penultima longa". This
--   <i>pinax</i> (<a>s1p7</a>) is for poetry in Iambic meter, 9-syllable
--   lines with long penultimate. There are four columns, one for each
--   successive line (but called "strophes"). There is only one
--   <a>RpermTable</a> for all four columns.
--   
--   It may be used with tone V, VI, VIII, X, and XII.
module Arca_musarithmica.Syntagma1.Pinax07

-- | Pinax 7
s1p7 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 91): "Metra Decasyllaba penultima breui". This
--   <i>pinax</i> (<a>s1p8</a>) is for poetry in 10-syllable lines with
--   short penultimate. There are four columns, one for each successive
--   line (but called "strophes"). There is only one <a>RpermTable</a> for
--   all four columns.
--   
--   It may be used with tone V, VI, VII, VIII, XI, and XII.
module Arca_musarithmica.Syntagma1.Pinax08

-- | Pinax 8
s1p8 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 93): "Musarithmos Melatheticos Poetics continens pro
--   Phaleucijs Hendecasyllabis". This <i>pinax</i> (<a>s1p9</a>) is for
--   poetry in 11-syllable lines (with long penultimate). There are four
--   columns, one for each successive line (but called "strophes"). There
--   is only one <a>RpermTable</a> for all four columns.
--   
--   This pinax only has nine rows of vperms.
--   
--   What look like the normal three groups of rperms are actually duple
--   major (cut C), duple minor (compasillo, C), and triple major (cut C
--   3). There is actually no rperm for triple minor (C3).
--   
--   It may be used with tone I, II, III, IV, and VII.
module Arca_musarithmica.Syntagma1.Pinax09

-- | Pinax 9
s1p9 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 93): "Pro Metris Sapphicis". This <i>pinax</i>
--   (<a>s1p10</a>) is for poetry in quatrains built of three 11-syllable
--   lines followed by an <a>Adonic</a> five-syllable line. There are four
--   columns, one for each successive line (but called "strophes"), where
--   the fourth column is for the Adonic tag line.
--   
--   There is only one <a>RpermTable</a> for the three 11-syllable columns,
--   and a separate one for the Adonic column.
--   
--   It may be used with tones I, II, III, IV, IX, and X.
module Arca_musarithmica.Syntagma1.Pinax10

-- | Pinax 10
s1p10 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark (bk II, p. 97): "Dodecasyllaba penultima breuia". This
--   <i>pinax</i> (<a>s1p11</a>) is for poetry in quatrains with
--   11-syllable lines with short penultimates. There are four columns, one
--   for each successive line (but called "strophes"). There is only one
--   <a>RpermTable</a> for all four columns.
--   
--   It may be used with tone V, VI, VII, VIII, XI, and XII.
module Arca_musarithmica.Syntagma1.Pinax11

-- | Pinax 11
s1p11 :: Pinax


-- | "Syntagma I. Melothesias siue Contrapuncti simplicis."
--   
--   Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark.
module Arca_musarithmica.Syntagma1

-- | To build the <i>syntagma</i>, convert the <i>pinakes</i> from lists to
--   vectors.
s1 :: Syntagma


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p1</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms.
--   
--   In one place (p. 103) Kircher says it is for inequal Adonic and
--   Dactylic meters:
--   
--   "Pinax 1. Melotheticus. In quo numeri harmonici pro metris Adoniis
--   &amp; Dactylicis inaequali quidem, sed Florida &amp; Artificioso vocum
--   progressu disponuntur."
--   
--   In the introduction to Syntagma II (p. 102), though, he says it is for
--   hectasyllabic Adonic and Dactylic meters:
--   
--   "<i>Primus Pinax</i> continet Musarithmos floridos &amp; artificiosos
--   pro metris Adonijs &amp; Dactylicis hectasyllabis."
--   
--   Either way, all the permutations are for <i>five</i> syllables except
--   for the florid (melismatic) voices.
--   
--   It is to be used with <i>tonoi</i> 5, 6, 7, 8, 11, and 12.
--   (<b>TODO</b>)
module Arca_musarithmica.Syntagma2.Pinax01

-- | Pinax 1
s2p1 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p2</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms. Kircher intends this for "Iambic, Euripidaeic, and
--   Hectasyllabic meters" (p. 106), with the paradigm being <i>Ave Maris
--   stella</i>.
--   
--   <pre>
--   PINAX II. "Musarithmi Melothesias Floridae siue Artificiose pro metris Iambicis, Euripedaeis, Hectasyllabis"
--   </pre>
--   
--   He does not give any limitations of tones.
module Arca_musarithmica.Syntagma2.Pinax02

-- | Pinax 2
s2p2 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p3</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms. Kircher intends this for "Anacreontic meters" (p.
--   109), with the paradigm being <i>O ter quaterque felix</i>.
--   
--   <pre>
--   PINAX III. "Musarithmos Melothesias Floridae siue Artificiosae continèns.
--   Pro metris Anacreonticis."
--   </pre>
--   
--   This pinax is for <i>toni</i> (tones) 1, 2, 3, 4, 9, and 10.
module Arca_musarithmica.Syntagma2.Pinax03

-- | Pinax 3
s2p3 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p4</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms.
--   
--   Kircher intends this for "pre-iambic archilochical" meters (p. 111),
--   with the paradigm being <i>Veni creator Spiritus</i>.
--   
--   <pre>
--   "PINAX IV. Melothesiae [-as?] floridae &amp; artificiosae Musarithmos continens PreIambicis Archilochijs."
--   </pre>
--   
--   This pinax is for these <i>toni</i> (tones):
--   
--   <ul>
--   <li>strophes 1--2: 5, 6, 7, 8, 11, and 12</li>
--   <li>strophes 3--4: 1, 2, 3, 4, 9, 10</li>
--   </ul>
--   
--   (really?)
module Arca_musarithmica.Syntagma2.Pinax04

-- | Pinax 4
s2p4 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p5</a>) contains four columns for
--   successive strophes. Each contains pairs of four-voice vperms and
--   four-voice rperms.
--   
--   Kircher intends this for meters with nine and ten syllable lines (p.
--   116), with the paradigm being <i>Amant venena parricida</i>.
--   
--   <pre>
--   "PINAX V. Melothesiae [-as?] Floridae &amp; artificiosae Musarithmos continens. Pro metris Enneasyllabis &amp; Decasyllabis."
--   </pre>
--   
--   This pinax is for <i>toni</i> (tones) 1, 2, 3, 4, 9, and 10.
module Arca_musarithmica.Syntagma2.Pinax05

-- | Pinax 5
s2p5 :: Pinax


-- | Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark. This <i>pinax</i> (<a>s2p6</a>) contains <i>three</i> columns for
--   successive strophes (actually meaning verse lines). Each contains
--   pairs of four-voice vperms and four-voice rperms.
--   
--   Kircher intends this for Saphhic meters with 11-syllable lines (p.
--   119), with the paradigm being <i>Ut queant laxis resonare fibris</i>.
--   Elsewhere he says it is for "Phaleucic/Hendecasyllabic and Sapphic
--   meters".
--   
--   <pre>
--   "PINAX VI. Musarithmos Melothesias Floridae &amp; artificiosae continens. Pro
--   </pre>
--   
--   metris sapphicis quibuslibet Hendecasyllabis."
--   
--   This pinax is for <i>toni</i> (tones) 1, 2, 3, 4, 9, and 10 in all
--   three "strophes."
--   
--   <b>TODO</b>: The problem is that in Sapphic meter there are stanzas of
--   four lines, where the first three are 11 syllables, and the last is
--   five (Adonic). In Syntagma I, Kircher builds this into the pinax, but
--   this one only accounts for those first three lines. We would have to
--   switch to a different pinax for every fourth line.
module Arca_musarithmica.Syntagma2.Pinax06

-- | Pinax 5
s2p6 :: Pinax


-- | "Syntagma II. Musarithmos Melothesias Floridae &amp; Artificiosae
--   continens"
--   
--   Sub-structures used by <tt>Arca_musarithmica</tt> to build Kircher's
--   ark.
module Arca_musarithmica.Syntagma2

-- | To build the <i>syntagma</i>, convert the <i>pinakes</i> from lists to
--   vectors.
s2 :: Syntagma


-- | <i>Arca musarithmica Athanasii Kircheri Societatis Iesu MDCL.</i>
--   
--   This module builds Kircher's ark as a Haskell data structure, using
--   the types and methods defined in the <tt>Aedifico</tt> module (see
--   that module for detailed description of the ark's structure and
--   implementation.)
--   
--   Like Kircher's physical implementation, this module is the container
--   for the data grouped by <i>syntagma</i>, each of which holds a group
--   of <i>pinakes</i> (rods with data tables).
--   
--   So far we have implemented only Syntagma 1, simple note-against-note
--   counterpoint.
module Arca_musarithmica

-- | To build the whole ark (<a>arca</a>), take the <i>syntagma</i> data
--   entered as a nested list and convert it to an <a>Arca</a> (which is a
--   vector of vectors down to the <a>Column</a> level).
--   
--   <pre>
--   arca = fromList [s0] :: Arca
--   </pre>
--   
--   <h1>How sub-elements are built</h1>
--   
--   To build the <i>syntagma</i>, convert the <i>pinakes</i> from lists to
--   vectors. s0' has two <i>pinakes</i>: one for long penultimate
--   syllables (<tt>s0p0</tt>) and one for short (<tt>s0p1</tt>).
--   
--   <pre>
--   s0 = fromList [s0p0, s0p1] :: Syntagma
--   </pre>
--   
--   We build the each <a>Pinax</a> from <a>Column</a>s. The first one
--   (<tt>s0p0</tt>) is for phrases with a long penultimate syllable. There
--   are five columns (<tt>c0</tt> ... <tt>c4</tt>). All the columns are a
--   2-tuple of a <a>Vperm</a> and an <a>Rperm</a>:
--   
--   <pre>
--   c0 = (c0v, c0r) :: Column
--   </pre>
--   
--   The first element (<tt>c0v</tt>) is a <a>VpermTable</a> with the pitch
--   numbers:
--   
--   <pre>
--   c0v :: VpermTable
--   c0v = fromList2D
--       [
--           [ -- 0
--               [5, 5],
--               [7, 8],
--               [2, 3],
--               [5, 1]
--           ],
--           [ -- 1
--               [5, 5],
--               [7, 7],
--               [2, 2],
--               [5, 5]
--           ],
--           ...
--       ]
--   </pre>
--   
--   The second element (<tt>c0r</tt>) is an <a>RpermTable</a> with
--   matching rhythm permutations in the three metrical categories:
--   
--   <pre>
--   c0r :: RpermTable
--   c0r = fromList2D
--       [
--           [ -- duple
--               [Sb, Sb],
--               [Mn, Mn],
--               [Sm, Sm],
--               [Fs, Fs],
--               [SbD, Mn],
--               [MnD, Sm],
--               [SmD, Fs]
--           ],
--           [ -- triple major
--               [Br, Sb],
--               [BrD, BrD]
--           ],
--           [ -- triple minor
--               [Sb, Mn]
--           ]
--       ]
--   </pre>
--   
--   The other columns are constructed similarly with the data from
--   Kircher.
--   
--   The arca also includes Kircher's list of notes in each tone with their
--   accidentals, a list indicating which tones are <i>cantus durus</i>
--   (all naturals in the signature) or <i>cantus mollis</i> (one B flat in
--   the signature), a list of which tones are acceptable in each
--   <i>pinax</i>, and a list of the acceptable ranges for each voice based
--   on the most conventional clef combination.
arca :: Arca

-- | Range for each voice, based on SATB C-clef ranges, generally up to one
--   note above and below the staff (Soprano C1, alto C3, tenor C4, bass f4
--   clefs), as shown on the front of the ark in Iconismus XIV. We are
--   using the untransposed ranges. These are notably different from those
--   of a modern mixed choir, as Kircher as all-male choirs in mind and the
--   alto clef gives a much lower range.
--   
--   NB (unimplemented part of specification):
--   
--   Kircher says that if a voice goes out of range, one option to fix it
--   is to switch to the transposing set of clefs shown on the ark. We are
--   not implementing this, because (1) nobody ever switched to transposing
--   clefs for a single phrase and then back, (2) we have a better
--   algorithm for setting the melodies within range than the incomplete
--   specification provided by Kircher
--   (<tt>Cogito.Musarithmia.stepwiseVoiceInRange</tt>).
_vocalRanges :: VoiceRanges

-- | Tone system (<a>Durus</a>, all naturals; or <a>Mollis</a>, one B flat)
--   per tone
_toneSystems :: ToneSystem

-- | Notes in the scale for each tone, with accidentals:
--   
--   Kircher includes suggested flats and sharps on notes likely to be
--   altered in <i>musica ficta</i> practice; in his tone tables he omits
--   the B flats that would always be added in tones in <i>cantus
--   mollis</i>
--   
--   We include both here, and elsewhere in the program we determine
--   whether the B flat is from the signature or should be treated as
--   <i>ficta</i>.
--   
--   The tones on p. 51 and on the Iconismus illustration do not agree. We
--   follow the (presumably later) version on the Iconismus, which corrects
--   errors in the <i>mensa tonographica</i> of p. 51.
_toneList :: ToneList

-- | Set of all tone labels
_allTones :: [Tone]

-- | Exclude elements of list in arg1 from list in arg2
listExclude :: (Foldable t, Eq a) => t a -> [a] -> [a]

-- | Create a list of tones, excluding blacklist from <tt>_allTones</tt>
allTonesExcept :: [Tone] -> [Tone]

-- | Tones appropriate for each pinax
_pinaxTones :: PinaxToneList


-- | This module provides the tools used in the main <tt>Cogito</tt> module
--   to adjust music created by the ark and to store it in internal
--   structures that will then be used by the <tt>Scribo</tt> modules.
--   
--   The <a>stepwiseVoiceInRange</a> function tests all the possible
--   permutations of octaves for the pitches in a phrase and finds the best
--   path, with the minimum of large leaps and notes out of range.
--   
--   Kircher's specification for how to put voices in range is incomplete,
--   and his own implementation is inconsistent, as demonstrated by his
--   examples. He says to find the next closest pitch "within the octave"
--   among the notes on the staff (i.e., the notes within range), but he
--   doesn't define "within the octave." Sometimes he leaps a fifth instead
--   of a fourth, which would break that rule.
--   
--   Sometimes a gesture requires the voice to go out of range. Kircher
--   says in that case you can switch clefs. But that doesn't change the
--   notes a singer can sing. If he means to change to transposing clefs,
--   that might work, but no one ever changed to transposing clefs for only
--   a single phrase and then went back.
--   
--   Instead, this module provides an algorithm that works every time to
--   produce an optimal melody with a small ambitus, minimum number of
--   notes outside of range, and small leaps. This seems very close to what
--   Kircher probably thought musicians would do intuitively, but did not
--   fully specify programmatically.
module Cogito.Musarithmetic

-- | A <a>Voice</a> is a list of pitches with an identifier for the voice
--   type.
data Voice
Voice :: VoiceName -> [Pitch] -> Voice

-- | Enum for Soprano, Alto, Tenor or Bass
[voiceID] :: Voice -> VoiceName
[music] :: Voice -> [Pitch]

-- | A <a>Chorus</a> is a group (list) of four <a>Voice</a> items
--   
--   <b>TODO</b>: We don't actually define it as being four items.
--   <b>TODO</b>: Do we still need this with new MEI setup?
type Chorus = [Voice]

-- | A <a>Note</a> contains a pitch and a syllable, equivalent to MEI
--   <tt>note</tt>
data Note
Note :: Pitch -> Syllable -> Note
[notePitch] :: Note -> Pitch
[noteSyllable] :: Note -> Syllable

-- | A <a>Syllable</a> is a single syllable to be paired with a
--   <a>Pitch</a>, including its position in the word.
data Syllable
Syllable :: String -> SyllablePosition -> Syllable
[sylText] :: Syllable -> String
[sylPosition] :: Syllable -> SyllablePosition

-- | What is the position of the syllable relative to the word? Beginning,
--   middle, or end? This determines hyphenation.
data SyllablePosition
First :: SyllablePosition
Middle :: SyllablePosition
Last :: SyllablePosition
Only :: SyllablePosition

-- | no syllable
Tacet :: SyllablePosition

-- | A <a>MusicPhrase</a> contains all the notes set using one permutation
--   drawn from the ark, for a single voice.
data MusicPhrase
MusicPhrase :: VoiceName -> [Note] -> MusicPhrase
[phraseVoiceID] :: MusicPhrase -> VoiceName
[notes] :: MusicPhrase -> [Note]

-- | A list of <a>MusicPhrase</a> items
type MusicSentence = [MusicPhrase]

-- | A <a>MusicSection</a> contains all the music for one section in the
--   input XML document, for a single voice, together with the parameters
--   set in the input file.
data MusicSection
MusicSection :: VoiceName -> ArkConfig -> [MusicSentence] -> MusicSection
[secVoiceID] :: MusicSection -> VoiceName
[secConfig] :: MusicSection -> ArkConfig
[secSentences] :: MusicSection -> [MusicSentence]

-- | A <a>MusicChorus</a> is a four-voice SATB structure of
--   <a>MusicSection</a> data. <b>TODO</b> do we really need it to be
--   structured this way?
data MusicChorus
MusicChorus :: MusicSection -> MusicSection -> MusicSection -> MusicSection -> MusicChorus
[soprano] :: MusicChorus -> MusicSection
[alto] :: MusicChorus -> MusicSection
[tenor] :: MusicChorus -> MusicSection
[bass] :: MusicChorus -> MusicSection

-- | The full <a>MusicScore</a> is a list of SATB <a>MusicChorus</a>
--   structures.
type MusicScore = [MusicChorus]

-- | Create a rest (that is, a <a>Pitch</a> with duration only)
--   
--   We make a <a>Pitch</a> but set the <a>pnum</a> to <a>Rest</a>;
--   <a>oct</a> and <a>accid</a> are set to special nil values
--   (<a>OctNil</a>, <a>AccidNil</a>)
--   
--   <b>TODO</b>: We are setting the octave using <tt>fromEnum OctNil</tt>:
--   Isn't this the same as just setting it to zero? Is there a better way
--   to mark this?
newRest :: Dur -> Pitch

-- | Is a tone in <i>cantus mollis</i>? Should there be a flat in the key
--   signature?
toneMollis :: Tone -> ToneSystem -> Bool

-- | Adjust a pitch to be in a given tone.
pnumAccidInTone :: Int -> ToneList -> Tone -> PnumAccid

-- | Get the modal final for this tone. What pitch = 0 in this tone? (In
--   Kircher's 1-indexed vperms, the final is 1 or 8.)
modalFinal :: ToneList -> Tone -> Pitch

-- | Check to see if a rhythmic duration is a rest type (the rest enums
--   begin with <a>LgR</a> so we compare with that)
isRest :: Dur -> Bool

-- | Is the <a>Pitch</a> a rest?
isPitchRest :: Pitch -> Bool

-- | Are any of these pitches rests?
anyRests :: [Pitch] -> Bool

-- | Convert <a>Pitch</a> to absolute pitch number, using chromatic
--   calculations (base 12). Raise an error if it is a rest.
absPitch :: Pitch -> Int

-- | Get chromatic offset from C for diatonic pitch classes (<tt>PCc -&gt;
--   0</tt>, <tt>PCd -&gt; 2</tt>, <tt>PCe -&gt; 4</tt>, etc.)
dia2chrom :: Pnum -> Int

-- | Absolute diatonic pitch (base 7). Raise an error if it is a rest.
absPitch7 :: Pitch -> Int

-- | Do mathematical operations on pitches (using their chromatic
--   <a>absPitch</a> values)
pitchMath :: (Int -> Int -> Int) -> Pitch -> Pitch -> Int

-- | Do mathematical operations on pitches (using their diatonic
--   <a>absPitch7</a> values)
pitchMath7 :: (Int -> Int -> Int) -> Pitch -> Pitch -> Int

-- | Do boolean tests on pitches (using their 'absPitch values)
pitchTest :: (Int -> Int -> Bool) -> Pitch -> Pitch -> Bool

-- | Are two <a>Pitch</a>es the same chromatic pitch, enharmonically
--   equivalent?
pEq :: Pitch -> Pitch -> Bool

-- | Pitch greater than?
pGt :: Pitch -> Pitch -> Bool

-- | Pitch less than?
pLt :: Pitch -> Pitch -> Bool

-- | Pitch greater than or equal?
pGtEq :: Pitch -> Pitch -> Bool

-- | Pitch less than or equal?
pLtEq :: Pitch -> Pitch -> Bool

-- | Difference between pitches, chromatic interval
p12diff :: Pitch -> Pitch -> Int

-- | Chromatic difference between pitch classes (within one octave);
--   <a>p12diff</a> modulo 12
p12diffMod :: Pitch -> Pitch -> Int

-- | Difference between pitches, diatonic interval Unison = 0, therefore
--   results of this function are one less than the verbal names of
--   intervals (<tt>p7diff = 4</tt> means a fifth)
p7diff :: Pitch -> Pitch -> Int

-- | Diatonic difference between pitch classes (= pitch difference as
--   though within a single octave); result is 0-indexed, so the interval
--   of a "third" in speech has a <tt>p7diffMod</tt> of 2
p7diffMod :: Pitch -> Pitch -> Int

-- | Take the absolute value of an intervals, the difference between
--   pitches. The interval between any note and a rest is zero.
absInterval :: Pitch -> Pitch -> Int

-- | Change the pitch class and octave of an existing <a>Pitch</a> to that
--   of an absolute diatonic pitch number. Return rests unchanged.
changePnumOctave :: Int -> Pitch -> Pitch

-- | Increase a pitch diatonically by a given interval (0-indexed diatonic,
--   e.g., <tt>p7inc p 4</tt> raises <tt>p</tt> by a diatonic third).
--   Return rests unchanged.
p7inc :: Pitch -> Int -> Pitch

-- | Just change the octave to a given number, no calculation required
octaveChange :: Pitch -> Int -> Pitch

-- | Increase the octave number by the given amount
octaveInc :: Pitch -> Int -> Pitch

-- | Raise the octave by 1
octaveUp :: Pitch -> Pitch

-- | Lower the octave by 1
octaveDown :: Pitch -> Pitch

-- | Is the pitch below the bottom limit of the voice range?
pitchTooLow :: VoiceRange -> Pitch -> Bool

-- | Is the pitch above the upper limit of the voice range?
pitchTooHigh :: VoiceRange -> Pitch -> Bool

-- | Is the <a>Pitch</a> within the proper range for its voice? Rests
--   automatically count as valid.
pitchInRange :: VoiceRange -> Pitch -> Bool

-- | Is this an acceptable leap? Only intervals up to a sixth, or an octave
--   are okay. If either note is a rest, then that also passes the test.
--   
--   TODO: Ignoring rests like this is a bit of a cop-out, but Kircher
--   usually puts rests at the beginning of a phrase, so they affect the
--   interval <i>between</i> phrases, which we are not adjusting anyway. In
--   an ideal scenario, we would.
legalLeap :: Pitch -> Pitch -> Bool

-- | Find the lowest valid instance of a given <a>Pitch</a> within the
--   <a>VoiceRange</a>. This is used to calculate an optimal path through
--   the possible pitches in a phrase, and means that in most cases the
--   melody will end up in the lower end of the voice's range.
lowestInRange :: VoiceRange -> Pitch -> Pitch

-- | List all the octaves within a voice range.
octavesInRange :: VoiceRange -> [Int]

-- | List all the valid instances of a given pitch within a voice range.
pitchesInRange :: VoiceRange -> Pitch -> [Pitch]

-- | Given a list of pitches (taken from the vperms in the ark), return a
--   list of list of all the valid instances of those pitches within a
--   particular voice range. This determines the candidate pitches that we
--   will test to find the optimal melody.
pitchCandidates :: VoiceRange -> [Pitch] -> [[Pitch]]

-- | Binary tree. We use a left-child/right-sibling binary tree to evaluate
--   any number of candidates for each element in the series.
data Btree a
Empty :: Btree a
Node :: a -> Btree a -> Btree a -> Btree a

-- | Build a general tree, implemented as left-child/right-sibling binary
--   tree that can take more than two options at each level
tree :: [[a]] -> Btree a

-- | Build a left-child/right-sibling tree from a list of the options at
--   each level, only including options that pass a test function; the test
--   function compares each parent to its child. If the value of the parent
--   (previous good value) is <a>Nothing</a> then we know it is the
--   beginning of the tree, there is no previous value to compare.
testTree :: (a -> a -> Bool) -> Maybe a -> [[a]] -> Btree a

-- | Make a list of all good paths in an LCRS tree. If no good paths are
--   found, the result will be <tt>[]</tt>.
paths :: [[a]] -> Btree a -> [[a]]

-- | Are all the elements of a list the same length?
sameLengths :: [[a]] -> Bool

-- | Prune out paths that are shorter than the original list of items. If
--   none are left after pruning (no viable paths), return <a>Nothing</a>.
fullPaths :: [a] -> [[b]] -> Maybe [[b]]

-- | The ambitus is the widest range of pitches used; the difference
--   between the highest and lowest pitches. Ignore rests.
ambitus :: [Pitch] -> Int

-- | Calculate and list intervals between pitches in a list. The list will
--   be one item shorter than the list of inputs.
intervals :: [Pitch] -> [Int]

-- | Add up all the intervals larger than a fourth (where p7diff &gt; 3
--   with 0-indexed intervals).
sumBigIntervals :: [Pitch] -> Int

-- | Find all the pitches that exceed a given range, and add up the
--   interval by which they go above or below the limits.
sumBeyondRange :: VoiceRange -> [Pitch] -> Int

-- | Calculate weighted "badness" score for a list of pitches. Sum of
--   ambitus, sum of large intervals (x 2), sum of degrees of notes out of
--   range (x 10).
badness :: VoiceRange -> [Pitch] -> Int

-- | Find the best path (first with lowest "badness"), or raise error if
--   none found
bestPath :: VoiceRange -> [Pitch] -> [[Pitch]] -> [Pitch]

-- | Choose the path with the lowest "badness"; if there are multiple with
--   the same score, choose the first
leastBadPath :: VoiceRange -> [[Pitch]] -> [Pitch]

-- | Build a tree of all pitch sequences with appropriate leaps
stepwiseTree :: [[Pitch]] -> Btree Pitch

-- | Find a melody for a voice with an optimal blend of avoiding bad leaps
--   and staying within range. This is the main function used in
--   <tt>Cogito</tt>.
--   
--   Avoid large or illegal leaps and stay as much in range as possible.
--   For example, some melodies have long stepwise ascents or descents
--   which, in certain tones, will take the voice out of range, and if we
--   adjust them in the middle, we will get an illegal seventh interval.
--   
--   We build a list of candidate pitches within the range, then we build a
--   tree of the ordered permutations of those pitches and test the paths
--   according to a subjective "badness" rating, including the ambitus or
--   total range of highest to lowest notes, the number and size of large
--   intervals, and the number of notes out of range (and how much out of
--   range they are). The first path with the lowest score wins.
stepwiseVoiceInRange :: VoiceRanges -> Voice -> Voice
instance GHC.Show.Show a => GHC.Show.Show (Cogito.Musarithmetic.Btree a)
instance GHC.Classes.Ord Cogito.Musarithmetic.MusicPhrase
instance GHC.Classes.Eq Cogito.Musarithmetic.MusicPhrase
instance GHC.Show.Show Cogito.Musarithmetic.MusicPhrase
instance GHC.Classes.Ord Cogito.Musarithmetic.Note
instance GHC.Classes.Eq Cogito.Musarithmetic.Note
instance GHC.Show.Show Cogito.Musarithmetic.Note
instance GHC.Classes.Ord Cogito.Musarithmetic.Syllable
instance GHC.Classes.Eq Cogito.Musarithmetic.Syllable
instance GHC.Show.Show Cogito.Musarithmetic.Syllable
instance GHC.Classes.Ord Cogito.Musarithmetic.SyllablePosition
instance GHC.Classes.Eq Cogito.Musarithmetic.SyllablePosition
instance GHC.Enum.Enum Cogito.Musarithmetic.SyllablePosition
instance GHC.Show.Show Cogito.Musarithmetic.SyllablePosition
instance GHC.Classes.Ord Cogito.Musarithmetic.Voice
instance GHC.Classes.Eq Cogito.Musarithmetic.Voice
instance GHC.Show.Show Cogito.Musarithmetic.Voice


-- | This module provides functions to adjust music created by the ark to
--   follow conventions of <i>musica ficta</i>.
module Cogito.Ficta

-- | Copy a <a>Note</a> but change the <a>Pitch</a>
changeNotePitch :: Note -> Pitch -> Note

-- | Copy a <a>Note</a> but adjust just its <a>Pitch</a> according to a
--   function.
adjustNotePitch :: (Pitch -> Pitch) -> Note -> Note

-- | Adjust the accidental either toward flats or toward sharps, within the
--   <a>Accid</a> enum. If the accidental is unset we just return the
--   original pitch. We are treating all accidental shifts as <i>musica
--   ficta</i> and giving a <a>Suggested</a> <a>accidType</a>.
accidentalShift :: Pitch -> Accid -> Pitch

-- | Lower a pitch a semitone
flatten :: Pitch -> Pitch

-- | Raise a pitch a semitone
sharpen :: Pitch -> Pitch

-- | Copy pitch but change <a>accid</a> and <a>accidType</a>
changeAccid :: Accid -> AccidType -> Pitch -> Pitch

-- | Change the <a>Accid</a> of the <a>Pitch</a> within a <a>Note</a>
changeNoteAccid :: Accid -> AccidType -> Note -> Note

-- | Cancel an accidental (suggested)
cancel :: Pitch -> Pitch

-- | Cancel the <a>Pitch</a> within a <a>Note</a>.
noteCancel :: Note -> Note

-- | Make <a>accidType</a> <a>Suggested</a>
fictaAccid :: Pitch -> Pitch

-- | Make <a>accidType</a> <a>Written</a>
writeAccid :: Pitch -> Pitch

-- | Do something to the <a>Note</a>s in every <a>MusicPhrase</a> within a
--   <a>MusicSection</a>
adjustNotesInSection :: ([Note] -> [Note]) -> MusicSection -> MusicSection

-- | Copy a <a>MusicPhrase</a> but with new notes
changeNotesInPhrase :: MusicPhrase -> [Note] -> MusicPhrase

-- | Do something to the <a>Note</a> list in a <a>MusicPhrase</a>
adjustNotesInPhrase :: ([Note] -> [Note]) -> MusicPhrase -> MusicPhrase

-- | Fold a ficta-adjusting function over a <a>MusicSection</a>
fixFictaInSection :: ([Note] -> Note -> [Note]) -> MusicSection -> MusicSection

-- | Fold a ficta-adjusting function over a <a>MusicPhrase</a>
fixFictaInPhrase :: ([Note] -> Note -> [Note]) -> MusicPhrase -> MusicPhrase

-- | Generate a stack folding function to process a list
foldStack :: ([a] -> a -> [a]) -> [a] -> [a]

-- | Compare two <a>MusicPhrase</a>s and find the note in the one (lower)
--   voice that coincides rhythmically with a given note in the other
--   (upper) voice. Used to find harmonies and test them for bad intervals.
--   
--   We find the top note by index and add the durations up to that point,
--   then we add the durations in the bottom voice up to each item (that
--   is, a scan) and then stop at the first item that matches the elapsed
--   duration of the top voice.
findCounterpoint :: MusicPhrase -> MusicPhrase -> Int -> Note

-- | What is the elapsed time of a <a>Dur</a> in units where <a>Fs</a>
--   (fusa) = 1?
durQuantity :: Dur -> Int

-- | Apply <i>ficta</i> adjustments to whole <tt>MusicPhrase</tt>s. Adjust
--   bass voice first; then adjust the upper voices individually, then
--   adjust them again relative to the bass.
adjustFictaChorus :: ToneSystem -> ToneList -> MusicChorus -> MusicChorus

-- | Adjust <i>musica ficta</i> for all the notes for one voice in a
--   'MusicSection.'
--   
--   These rules are based on Kircher but had to be expanded as he doesn't
--   account for some important and common cases.
--   
--   TODO they still don't deal with every problem. Some would be
--   automatically corrected by competent performers.
--   
--   #^7: - If the tone table has 8, keep the sharp - If it has #^7 and it
--   is the last note in the phrase, and it is not the bass voice, keep the
--   sharp - Otherwise make it natural
--   
--   b^6: - If the tone table has b^6, cancel the flat if the next note is
--   #^7
--   
--   After making either of the above adjustments, go through and check for
--   repeated notes: make them match the next accidental (G♮-G# should be
--   G).
adjustFictaVoice :: ToneList -> Tone -> MusicSection -> MusicSection

-- | Adjust <i>musica ficta</i> in an upper voice relative to the bass.
--   Avoid cross relations and augmented fifths. (I guess tritones are
--   okay?)
adjustRelBass :: ToneList -> Tone -> MusicSection -> MusicSection -> MusicSection

-- | Map a function to the phrases in one section (upper voice) relative to
--   the phrases in another section (lower voice).
adjustPhrasesInSection :: (MusicPhrase -> MusicPhrase -> MusicPhrase) -> MusicSection -> MusicSection -> MusicSection

-- | Apply <i>musica ficta</i> adjustments to a whole <a>MusicPhrase</a>
--   relative to the bass phrase.
adjustFictaPhrase :: ToneList -> Tone -> MusicPhrase -> MusicPhrase -> MusicPhrase

-- | Return the 0-indexed scale degree of a given pitch in a given tone
--   (scale degree 0 is the modal final)
scaleDegree :: ToneList -> Tone -> Pitch -> Int

-- | 1-indexed scale degree (more intelligible to the musical programmer)
scaleDegree1 :: ToneList -> Tone -> Pitch -> Int

-- | Does this <a>Pitch</a> have the given accidental as <a>Suggested</a>?
isFictaAccid :: Accid -> Pitch -> Bool

-- | Apply <a>isFictaAccid</a> to a <a>Note</a>
isFictaAccidNote :: Accid -> Note -> Bool

-- | Fix bad intervals against a lower voice in a <a>MusicPhrase</a>
fixIntervalsInPhrase :: MusicPhrase -> MusicPhrase -> MusicPhrase

-- | No cross relations or augmented fifths between upper and lower note
--   (TODO tritones?)
fixIntervals :: Note -> Note -> Note

-- | Are these pitches the same pitch class but different accidentals?
--   (E.g., F vs F#?)
isCrossRelation :: Pitch -> Pitch -> Bool

-- | Are these pitches an augmented fifth apart?
isAugFifth :: Pitch -> Pitch -> Bool


-- | This module reads (<i>lectio</i>, Latin, "I read") and process input
--   text to be set to music using the ark.
--   
--   <h1>Kircher's specification</h1>
--   
--   Kircher expects the user to prepare a text by segmenting it into
--   phrases according to the poetic meter and prosody. In his description
--   the texts are Latin, but he also demonstrates how the machine could be
--   used with Aramaic and other languages, ideally by Jesuit missionaries.
--   
--   <h1>Implementation</h1>
--   
--   <h2>XML input</h2>
--   
--   In our implementation we also expect the user to mark the input text
--   by dividing the syllables with hyphens and marking the long syllables
--   with accent symbols (<tt>`</tt>, placed before the relevant syllable),
--   for example:
--   
--   <pre>
--   Lau-`da-te `Do-mi-num `om-nis `ter-rae. Al-le-`lu-ia. A-`men.
--   </pre>
--   
--   This implementation takes input in the form of an XML document, in
--   which the text is syllabified and accented as just demonstrated, and
--   divided into one or more sections. In the attributes for each
--   <tt>&lt;section&gt;</tt> element, the user sets the values we need as
--   input for the ark:
--   
--   <ul>
--   <li><i><tt>textMeter</tt></i> e.g., <tt>Prose</tt> or
--   <tt>Adonium</tt></li>
--   <li><i><tt>musicMeter</tt></i> <tt>Duple</tt>, <tt>TripleMinor</tt>,
--   or <tt>TripleMajor</tt></li>
--   <li><i><tt>style</tt></i> <tt>Simple</tt> (= Syntagma I) or
--   <tt>Florid</tt> (= Syntagma II)</li>
--   <li><i><tt>tone</tt></i> e.g., <tt>Tone1</tt></li>
--   </ul>
--   
--   Within each section the text is divided into one or more line groups
--   (<tt>&lt;lg&gt;</tt>) and lines (<tt>&lt;l&gt;</tt>). (These elements
--   are borrowed from TEI.)
--   
--   <h3><b>TODO</b></h3>
--   
--   In Prose meter, Kircher leaves it up to the user to divide the text
--   into phrases. We are currently using a very simple algorithm to divide
--   the text into phrase groups within the correct size range. It would be
--   better to use a more sophisticated algorithm to parse the text into
--   optimal groups.
--   
--   <h2>Reading and parsing the input file</h2>
--   
--   The main function is <a>prepareInput</a>, which reads and parses the
--   file and produces a list of <a>LyricSection</a>s.
--   
--   This module reads the input file, parses the XML tree to extract the
--   text and needed parameters for setting the text (within each section),
--   and then packages the text into its own data structures to pass on to
--   the other parts of the program (<tt>Cogito</tt> for processing and
--   <tt>Scribo</tt> for writing output).
--   
--   <h3>Capturing XML data</h3>
--   
--   The text is first grouped into intermediate data structures that
--   closely reflect the XML structure. Each <tt>&lt;section&gt;</tt>
--   becomes an <a>ArkTextSection</a>, containing a nested list of strings
--   (line groups and lines from XML) and an <a>ArkConfig</a> with the
--   parameters from the XML section attributes. The list of these is
--   packaged into a single <a>ArkInput</a> structure containing metadata
--   for the whole document (taken from the XML <tt>&lt;head&gt;</tt>), and
--   a list of <a>ArkTextSection</a>s.
--   
--   <h3>Preparing for musical setting</h3>
--   
--   The module then processes this data and converts it into a list of
--   <a>LyricSection</a>s that the other modules will use. Below are the
--   structures that are passed on to other modules, from top down. Each
--   structure contains the element below it, plus information about it
--   (length, number of syllables, etc.). To get that information, these
--   structures are created with methods that calculate the data upfront.
--   
--   <ul>
--   <li><i><a>LyricSection</a></i> group of sentences (from
--   <tt>&lt;section&gt;</tt>)</li>
--   </ul>
--   
--   <ul>
--   <li>also contains an <a>ArkConfig</a> with the text-setting
--   parameters</li>
--   </ul>
--   
--   <ul>
--   <li><i><a>LyricSentence</a></i> group of phrases (from
--   <tt>&lt;lg&gt;</tt>)</li>
--   <li><i><a>LyricPhrase</a></i> group of words (from
--   <tt>&lt;l&gt;</tt>)</li>
--   <li><i><a>Verbum</a></i> individual word, broken into syllables</li>
--   </ul>
module Lectio

-- | The character used to demarcate syllables (default <tt>'-'</tt>)
hyphenChar :: Char

-- | The character used at the beginning of syllables to show long (or
--   accented) syllables (default <tt>'`'</tt>)
accentChar :: Char

-- | Header information
data ArkMetadata
ArkMetadata :: String -> String -> ArkMetadata
[arkTitle] :: ArkMetadata -> String
[arkWordsAuthor] :: ArkMetadata -> String

-- | The input to the ark is an <a>ArkConfig</a> element with tone, style,
--   and meter; and a list of strings, each of which will become a
--   <a>LyricSentence</a>
data ArkInput
ArkInput :: ArkMetadata -> [ArkTextSection] -> ArkInput
[arkMetadata] :: ArkInput -> ArkMetadata
[arkTextSections] :: ArkInput -> [ArkTextSection]

-- | A section of input text (from xml section element)
data ArkTextSection
ArkTextSection :: ArkConfig -> [[String]] -> ArkTextSection
[arkConfig] :: ArkTextSection -> ArkConfig

-- | list of <tt>&lt;lg@&gt; containing lists of </tt>&lt;l&gt;@
[arkText] :: ArkTextSection -> [[String]]

-- | Create a <a>QName</a> to search the xml tree
xmlSearch :: String -> QName

-- | Get the text from a node
xmlNodeText :: String -> Element -> String

-- | For each string in list, break text into strings at newlines, strip
--   leading and trailing whitespace, remove empty strings, remove newlines
cleanUpText :: [String] -> [String]

-- | Strip leading and trailing whitespace from a <a>String</a>
strip :: String -> String

-- | Read an XML string and return the data for input to the ark
--   (<a>ArkInput</a>)
readInput :: String -> ArkInput

-- | Parse an XML node tree into a section with configuration and parsed
--   text.
parseSection :: Element -> ArkTextSection

-- | Every syllable is either <a>Long</a> or <a>Short</a>.
type SylLen = PenultLength

-- | Our data type for a word includes the original text of the word, that
--   text chunked into syllables, the count of those syllables, and a
--   marker of whether the penultimate syllable is short or long.
data Verbum
Verbum :: String -> [String] -> Int -> SylLen -> Verbum

-- | original text
[verbumText] :: Verbum -> String

-- | text divided into list of syllables
[verbumSyl] :: Verbum -> [String]

-- | number of syllables
[sylCount] :: Verbum -> Int

-- | length of next-to-last syllable
[penultLength] :: Verbum -> SylLen

-- | A <a>LyricPhrase</a> is a group of <a>Verbum</a> items (words): it
--   contains the list of words, the total count of syllables in the
--   phrase, and a marker for the phrase's penultimate syllable length.
data LyricPhrase
LyricPhrase :: [Verbum] -> Int -> SylLen -> Int -> LyricPhrase

-- | list of words
[phraseText] :: LyricPhrase -> [Verbum]

-- | total syllables in all words
[phraseSylCount] :: LyricPhrase -> Int

-- | length of next-to-last syllable in whole phrase
[phrasePenultLength] :: LyricPhrase -> SylLen

-- | position in list of phrases
[phrasePosition] :: LyricPhrase -> Int

-- | Each sentence includes the number of phrases therein
type PhrasesInLyricSentence = Int

-- | A list of totals of phrases in a section
type PhrasesInLyricSection = [PhrasesInLyricSentence]

-- | A <a>LyricSentence</a> is just a list of <a>LyricPhrase</a> items.
data LyricSentence
LyricSentence :: [LyricPhrase] -> PhrasesInLyricSentence -> LyricSentence
[phrases] :: LyricSentence -> [LyricPhrase]

-- | number of phrases
[sentenceLength] :: LyricSentence -> PhrasesInLyricSentence

-- | A <a>LyricSection</a> includes a list of <a>LyricSentence</a>s and an
--   <a>ArkConfig</a>.
--   
--   Including an <a>ArkConfig</a> structure makes it possible to structure
--   the input text and program the ark to change meters or tones for
--   different sections.
data LyricSection
LyricSection :: ArkConfig -> [LyricSentence] -> LyricSection
[sectionConfig] :: LyricSection -> ArkConfig
[sentences] :: LyricSection -> [LyricSentence]

-- | Get the number of phrases per sentence for a whole section.
sectionPhraseLengths :: LyricSection -> PhrasesInLyricSection

-- | Get the phrase lengths for the whole input structure
inputPhraseLengths :: [LyricSection] -> [PhrasesInLyricSection]

-- | Make a <a>LyricSentence</a> from a list of <a>LyricPhrase</a>s.
newLyricSentence :: [LyricPhrase] -> LyricSentence

-- | Take a simple list of <a>Verbum</a> items and make a
--   <a>LyricPhrase</a> structure from it: the original list is stored as
--   <a>phraseText</a>, and the <a>phraseSylCount</a> and
--   <a>phrasePenultLength</a> are calculated from that list. The
--   <a>phraseSylCount</a> is the sum of all the <a>sylCount</a>s of the
--   words in the list. The <a>phrasePenultLength</a> is the
--   <a>penultLength</a> of the last list item.
newLyricPhrase :: [Verbum] -> LyricPhrase

-- | Take a <a>String</a> and create a <a>Verbum</a> structure:
--   
--   <ul>
--   <li>strip the text of diacritics by removing <a>hyphenChar</a> and
--   <a>accentChar</a> characters</li>
--   <li>extract syllables by stripping accents and splitting at
--   hyphens</li>
--   <li>get syllable count from list created in previous step</li>
--   <li>get penultimate syllable length from list of syllables
--   <i>including</i> accents, using <a>penultValue</a></li>
--   </ul>
newVerbum :: String -> Verbum

-- | Determine the length of the next-to-last in a list of strings. If the
--   list length is 1 or shorter, or if there is no <a>accentChar</a> at
--   the beginning of the penultimate syllable (found using <a>penult</a>),
--   then the result is <a>Short</a>; otherwise <a>Long</a>.
penultValue :: [String] -> SylLen

-- | Return the next-to-last item in a list.
penult :: [a] -> Maybe a

-- | Regroup a phrase int groups of words with total syllable count in each
--   group not to exceed a given maximum.
--   
--   <b>TODO</b>: Replace with more sophisticated algorithm: - what to do
--   if word is longer than maxSyllables? (break it into parts?) - optimize
--   this for best grouping, not just most convenient in-order
rephrase :: Int -> LyricPhrase -> [LyricPhrase]

-- | Prepare the entire input structure
prepareInput :: ArkInput -> [LyricSection]
instance GHC.Classes.Ord Lectio.LyricSection
instance GHC.Classes.Eq Lectio.LyricSection
instance GHC.Show.Show Lectio.LyricSection
instance GHC.Classes.Ord Lectio.LyricSentence
instance GHC.Classes.Eq Lectio.LyricSentence
instance GHC.Show.Show Lectio.LyricSentence
instance GHC.Classes.Ord Lectio.LyricPhrase
instance GHC.Classes.Eq Lectio.LyricPhrase
instance GHC.Show.Show Lectio.Verbum
instance GHC.Classes.Ord Lectio.Verbum
instance GHC.Classes.Eq Lectio.Verbum
instance GHC.Show.Show Lectio.ArkInput
instance GHC.Show.Show Lectio.ArkTextSection
instance GHC.Show.Show Lectio.ArkMetadata
instance GHC.Show.Show Lectio.LyricPhrase


-- | Kircher's ark does require a small amount of free choice on the part
--   of the user, in selecting which voice permutation and rhythm
--   permutation to use from each column. We take the (for Kircher)
--   theologically dangerous route of chance operations and generate a
--   random number for the index of the voice and rhythm permutations.
module Fortuna

-- | A <tt>Perm</tt> stores the random number choices used to select voice
--   and rhythm permutations.
data Perm
Perm :: Int -> Int -> Perm
[voiceIndex] :: Perm -> Int
[rhythmIndex] :: Perm -> Int

-- | Make a pair of random numbers to select vperm and rperm:
--   
--   <ul>
--   <li>vperm is always one of 10 vperms per column</li>
--   <li>rperm lists are variable in length, so we choose a larger number
--   and then take the modulo of the length of the list once it's selected
--   (in <tt>Aedifico</tt>)</li>
--   </ul>
choosePerms :: IO Perm

-- | Each sentence needs a list of perms, one per phrase
type SentencePerm = [Perm]

-- | A list of perms for each sentence in the section
type SectionPerm = [SentencePerm]

-- | Generate a list of <a>Perm</a>s of a given length to match a
--   <tt>Sentence</tt>
sentencePerms :: PhrasesInLyricSentence -> IO SentencePerm

-- | Generate perms for a whole section
sectionPerms :: PhrasesInLyricSection -> IO SectionPerm

-- | Generate perms for the whole input structure
inputPerms :: [PhrasesInLyricSection] -> IO [[SentencePerm]]
instance GHC.Show.Show Fortuna.Perm


-- | This module processes data from the ark to convert it into music
--   (<i>cogito</i>, Latin, "I think").
--   
--   <h1>Overview</h1>
--   
--   This module receives input from the <tt>Lectio</tt> module in the form
--   of a single list of one or more <a>LyricSection</a>s, which contain
--   the parsed text to be set to music and the parameters for setting it.
--   
--   The module uses Kircher's rules to pull the appropriate data from the
--   Arca musarithmica, that is, from the <a>Arca</a> built by the
--   <tt>Aedifico</tt> module. It uses the <tt>Fortuna</tt> module to get
--   lists of random permutation indices.
--   
--   The main function is <a>makeMusicScore</a>, which applies all the
--   necessary rules to select music data from the ark for each phrase of
--   text, using the random permutations when a free choice would otherwise
--   be needed. It takes the numerals and rhythmic symbols from Kircher's
--   <i>pinakes</i> (rods); converts the numerals to pitches according to
--   the tone, and combines the pitches and rhythms (accounting for rests
--   as well).
--   
--   The module creates the <a>MusicScore</a> data structure which contains
--   all the data for the music in hierarchical sections that the
--   <tt>Scribo</tt> module will convert to MEI XML.
--   
--   <h2>Text underlay</h2>
--   
--   Pitches and syllables are stored together in the <a>Note</a> type. In
--   Syntagma I (simple syllabic counterpoint), we store one syllable for
--   each note, skipping rests.
--   
--   In Syntagma II, though, for florid counterpoint, Kircher does not
--   specify how to underlay the text, and the settings have variable
--   numbers of notes in the different voices and between different
--   permutations in the same <i>pinax</i>. The underlay must be left to
--   the human performer, then, and so we just lump all the lyrics for each
--   phrase and put them under the first syllable as a textual incipit.
--   
--   <h2>MEI vs. Lilypond output</h2>
--   
--   We previously set up this module to feed data into the
--   <tt>Scribo.Lilypond</tt> module, using the main function
--   <tt>getSymphonia</tt>. It treated pitches and lyrics completely
--   separately, which worked in Syntagma I but not in Syntagma II. These
--   functions are archived in the <tt>test/</tt> directory.
module Cogito

-- | Take two lists and zip them together, that is, make a new list of
--   ordered pairs constructed from sequential items of the two lists, BUT:
--   if an element in the first list satisfies a given <tt>test</tt>, make
--   a pair of that element and a sustitute element (<tt>sub</tt>) instead
--   of the corresponding element from the second list.
zipFill :: [a] -> [b] -> (a -> Bool) -> b -> [(a, b)]

-- | Make a pitch from duration and pitch number. Start with zero octave;
--   we'll set it later using <a>stepwiseVoiceInRange</a>. Adjust the pitch
--   for tone (<a>pnumAccidInTone</a>).
--   
--   <b>TODO</b>: This could also be generalized; we are not checking
--   inputs because we control data input.
pair2Pitch :: ToneList -> ToneSystem -> Tone -> (Dur, Int) -> Pitch

-- | Is this note a B flat, and if so, is the flat already in the key
--   signature?
isBflatInSignature :: Pnum -> Accid -> Tone -> ToneSystem -> Bool

-- | Get the right starting octave range for each voice type voice2octave
--   :: VoiceName -&gt; Int
voice2octave :: Num p => VoiceName -> p

-- | Central functions of the ark: given all parameters required by Kircher
--   (style, meter, syllable count, penultimate syllable length), select a
--   voice permutation (Kircher's number tables) from the appropriate part
--   of the ark and match it to a rhythm permutation (his tables of note
--   values).
--   
--   Return a <a>Voice</a> with the pitches for a single voice part.
--   
--   We use <a>getVoice</a> and <a>getRperm</a> from the <tt>Aedifico</tt>
--   module.
--   
--   Because the rhythms can include rest, we have to match up pitches and
--   rhythms accordingly using <a>zipFill</a> with the test <a>isRest</a>.
ark2voice :: Arca -> ArkConfig -> PenultLength -> Int -> Int -> VoiceName -> Perm -> Voice

-- | Take a <a>Verbum</a> read from the input file and turn it into a list
--   of <a>Syllable</a>s for storage in <a>Note</a>s. Record the syllable's
--   position within the word.
makeSyllables :: Verbum -> [Syllable]

-- | Just a blank syllable for filler when needed
blankSyllable :: Syllable

-- | Compose the music for a whole <a>LyricPhrase</a> with one permutation
--   from the ark, and package it into a <a>MusicPhrase</a>. Note that this
--   is for a single voice only, not the four SATB voices.
--   
--   Line up pitches and syllables, skipping rests. In Syntagma I, line up
--   text and notes syllabically (one syllable per note); in syntagma II
--   (florid), lump the text into a single syllable and put it as an
--   incipit text at the beginning of the phrase. (See module description
--   for why Kircher's specification makes this is necessary.)
makeMusicPhrase :: Arca -> ArkConfig -> VoiceName -> LyricPhrase -> Perm -> MusicPhrase

-- | Compose music for a <a>LyricSentence</a> for a single voice.
makeMusicSentence :: Arca -> ArkConfig -> VoiceName -> LyricSentence -> SentencePerm -> MusicSentence

-- | Put together all the music information for one <a>LyricSection</a>,
--   for a single voice.
--   
--   <ul>
--   <li>For a single voice:<ul><li>extract ArkConfig for whole
--   section</li><li>for each sentence in section:<ul><li>extract list of
--   perms, one per phrase</li><li>extract list of lyric
--   phrases</li><li>apply same ArkConfig</li></ul></li><li>for each phrase
--   in sentence:<ul><li>look up vperm according to config and
--   perm<ul><li>(for some pinakes, choose column by stanza = section
--   num)</li></ul></li><li>look up rperm according to config and
--   perm<ul><li>(for syntagma II, use same perm)</li></ul></li><li>convert
--   vperm nums to pitch names</li><li>(adjust pitches)</li><li>make
--   Pitches: match pitches and rhythms, accounting for rests</li><li>match
--   Notes: match each Pitch with Phrase<i>Verbum</i>Syllable according to
--   syntagma</li><li>return a MusicPhrase</li></ul></li><li>inside a
--   MusicSentence</li></ul></li>
--   <li>inside a MusicSection</li>
--   </ul>
makeMusicSection :: Arca -> LyricSection -> SectionPerm -> VoiceName -> MusicSection

-- | Compose music for all four SATB voices for one <a>LyricSection</a>.
--   TODO experimental: also adjust for musica ficta
makeMusicChorus :: Arca -> LyricSection -> SectionPerm -> MusicChorus

-- | Compose the music for the whole document as a <a>MusicScore</a>,
--   pulling the data from the <a>Arca</a>.
makeMusicScore :: Arca -> [LyricSection] -> [SectionPerm] -> MusicScore


-- | This module is our implementation of Kircher's <i>palimpsest
--   phonotacticum</i>, his system for writing out the music created using
--   the ark. Certain elements that Kircher used notation to calculate
--   (like determining vocal ranges by clef combinations and the size of
--   the staff) we actually do in the <tt>Cogito</tt> module. This module
--   is purely focused on output of complete music information to a
--   music-notation language.
--   
--   This module outputs to Lilypond, which could then be processed by that
--   program to PDF, MIDI, or other formats.
--   
--   This is a stub of what used to be a full Lilypond writing module (now
--   archived in test/). We just use this for testing.
module Scribo.Lilypond

-- | Write pitch as Lilypond music note. Look up needed string values for
--   letter name, accidental, octave tick marks, and duration in lists
--   based on data in given <a>Pitch</a>. If it is a <a>Rest</a>, just
--   print the rest rhythm string.
--   
--   Most of these just require using an enum value as index to a list of
--   strings or characters. The octave requires us to calculate the number
--   of commas or apostrophes to add (relative to Helmholtz octave 3 =
--   <tt>c</tt>).
pitch2ly :: Pitch -> String


-- | This module is our implementation of Kircher's <i>palimpsest
--   phonotacticum</i>, his system for writing out the music created using
--   the ark. Certain elements that Kircher used notation to calculate
--   (like determining vocal ranges by clef combinations and the size of
--   the staff) we actually do in the <tt>Cogito</tt> module. This module
--   is purely focused on output of complete music information to a
--   music-notation language.
--   
--   This module outputs in the XML format of the Music Encoding Initiative
--   (MEI).
--   
--   This means that the whole arca program is transforming an input XML
--   document with the text and parameters into and output XML document
--   with the text matched to music.
module Scribo.MEI

-- | Put a string between two other strings
enbrace :: String -> String -> String -> String

-- | Create an XML opening tag, e.g., <tt><a>p</a></tt>
xmltagOpen :: String -> String

-- | Create an XML closing tag, e.g., <tt><a>/p</a></tt>
xmltagClose :: String -> String

-- | Put something between opening and closing XML tags, specifying text of
--   opening tag, contents, and closing tag: &gt; xmlWrap "p" "text" "p"
--   =&gt; <a>p</a>text<a>/p</a>
xmlWrap :: String -> [String] -> String -> String

-- | Put something between XML tags, with the same text for opening and
--   closing: &gt; xmlWrapBasic "p" "text" =&gt; <a>p</a>text<a>/p</a>
xmlWrapBasic :: String -> [String] -> String

-- | Create an XML element (which may contain other elements). If you need
--   attributes, use <a>elementAttr</a>.
element :: String -> [String] -> String

-- | Create an XML attribute
attr :: String -> String -> String

-- | Create an XML element that has attributes, e.g.,
--   <tt><a>class="foo"</a>bar<a>/p</a></tt>
elementAttr :: String -> [String] -> [String] -> String

-- | Create an MEI <tt>note</tt> element from our <tt>Note</tt> datatype,
--   converting the attributes as needed. If the <tt>Note</tt> actually
--   contains a rest (<a>Pitch</a> with only a <a>Dur</a> in the rest
--   range), then produce a <tt>rest</tt> element.
note2mei :: Note -> String

-- | Convert <a>Pnum</a> to MEI <tt>pname</tt>
meiPname :: Pitch -> String

-- | Just print the octave number
meiOct :: Pitch -> String

-- | Convert <a>Dur</a> to MEI <tt>dur</tt> (base value of duration) and
--   @dots (if any; omit if not)
meiDur :: Pitch -> String

-- | Convert our <a>Accid</a> to MEI <tt>accid</tt> (omit if natural)
--   
--   <b>TODO</b> Verovio will display the accidental if the <tt>accid</tt>
--   attribute or element is present, regardless of the key signature. We
--   would need to check the tone/key and then use accid.ges for
--   accidentals that are in the key signature.
meiAccid :: Pitch -> String

-- | If a word is a single syllable, we do not need to include
--   <tt>@con</tt> or <tt>@wordpos</tt>; if it is more than one syllable,
--   we include these attributes. We use a dash connector by default, and
--   get the word position from the data in the <a>Syllable</a> type.
meiSyllable :: Syllable -> String

-- | Where is this item in the list that contains it?
data ListPosition

-- | head of list
ListHead :: ListPosition

-- | neither head nor last
ListBody :: ListPosition

-- | last item in list
ListEnd :: ListPosition

-- | only item of a one-item list
ListOnly :: ListPosition

-- | Given a function that takes a ListPosition argument and a list, apply
--   the function to the list. This allows you to treat the first and last
--   items in the list differently.
positionMap :: ((ListPosition, a1) -> [a2]) -> [a1] -> [a2]

-- | Mark a list with the positions of the items: first, body, and last.
--   Output a list of pairs with the <a>ListPosition</a> and the original
--   list item.
markedEnds :: [a] -> [(ListPosition, a)]

-- | Make an XML string containing a list of <tt>note</tt> elements out of
--   a <a>MusicPhrase</a>; end each phrase with <tt>barline</tt>, except
--   for last in the list.
--   
--   Leave the barline of the last phrase up to the next-higher function
--   (end of sentence gets regular bar; end of sentence, double bar; end of
--   section, final bar).
phrase2mei :: (ListPosition, MusicPhrase) -> String

-- | Make an XML string containing all the contents of one <tt>layer</tt>
--   out of a <a>MusicSentence</a>. If this is the last sentence in the
--   section, omit the bar so the higher function calling this one can add
--   it. Sentence ends with regular barline.
sentence2mei :: (ListPosition, MusicSentence) -> String

-- | A <a>MusicSection</a> contains all the music for one section, /for a
--   single voice/: so combine all subdivisions into one <tt>staff</tt> and
--   <tt>layer</tt> so this can be made part of an MEI <tt>section</tt> in
--   <a>chorus2mei</a>. Include MEI 1-indexed staff number derived from
--   <a>VoiceName</a> enum Put a double bar at the end of sections and a
--   final bar at the end of the piece.
--   
--   <b>TODO</b>: you could put more than one layer per staff if you wanted
--   a 2-staff choirstaff (e.g., SA on one, TB on the other)
section2mei :: Arca -> (ListPosition, MusicSection) -> String

-- | Take a list of sections, one per SATB voice, and create a single MEI
--   <tt>section</tt> including all the voices. Add a final bar at the end.
chorus2mei :: Arca -> (ListPosition, MusicChorus) -> String

-- | Create an MEI key signature (all naturals or one flat) based on tone
--   (<tt>key.sig</tt> attribute for use in
--   <tt>scoreDef</tt>/<tt>staffDef</tt>)
meiKey :: Tone -> ToneSystem -> String

-- | MEI key signature as an attribute (for use in <tt>staffDef</tt>)
meiKeyAttr :: Tone -> ToneSystem -> String

-- | Value for MEI <tt>key.sig</tt>: one flat if tone is <i>mollis</i>, no
--   signature otherwise
meiKeySigString :: Tone -> ToneSystem -> String

-- | Switch to select which kind of meter to use as an element
meiMeter :: MusicMeter -> String

-- | Switch to select which kind of meter to use as an attribute
meiMeterAttr :: MusicMeter -> String

-- | Create an MEI meter signature (using modern equivalents of Kircher's
--   C, C3, cutC3). (<tt>meterSig with </tt>meter.count<tt> and
--   </tt>meter.unit<tt> attributes for use in
--   </tt>scoreDef<tt>/</tt>staffDef@)
meiMeterModern :: MusicMeter -> String

-- | Mensural version of <a>meiMeter</a>. We want either "cut C",
--   <a>C3</a>, or "cutC3". Verovio does not render these correctly as of
--   2021/07 when using the <tt>proport</tt> element (or
--   <tt>proport.num</tt> attribute) for the number, which is the correct
--   encoding. But putting <tt>num</tt> directly inside <tt>mensur</tt>
--   works with Verovio.
meiMeterMensural :: MusicMeter -> String

-- | Mensural meter with proportion as a string of attributes (for use in
--   <tt>staffDef</tt>, where the correct encoding also works with
--   Verovio).
meiMeterMensuralAttr :: MusicMeter -> String

-- | MEI <tt>tempo</tt> element for MIDI speed: quarter-note (semiminim)
--   beats per minute, different tempi for each mensuration
meiMidiTempo :: MusicMeter -> String

-- | MEI <tt>midi.bpm</tt> attribute appropriate for each mensuration This
--   is how it should work, but Verovio does not accept a tempo element
--   within staff, so I do not know how to do a tempo change mid-piece.
meiMidiBPM :: MusicMeter -> String

-- | Extract a simple list of <a>MusicSentence</a> from the four members of
--   a <a>MusicChorus</a>
chorus2list :: MusicChorus -> [MusicSection]

-- | Convert a whole <a>MusicScore</a> to MEI XML. Include meter and key of
--   first section in top-level <tt>scoreDef</tt> (<b>TODO</b> ?) Pass on
--   the position in the list to the next function down.
score2mei :: Arca -> ArkMetadata -> MusicScore -> String

-- | Make an MEI double barline
meiDoubleBar :: String

-- | Make an MEI final barline
meiFinalBar :: String

-- | Make an MEI <tt>barLine</tt> element
meiBarline :: String -> String

-- | Default XML header
_xmlHeader :: [Char]

-- | MEI version number
_meiVersion :: [Char]

-- | The "composer" (that is, the ark itself)
_whoami :: [Char]

-- | The "inventor"
_Kircher :: [Char]

-- | The "programmer" and "text preparer"
_AAC :: [Char]

-- | MEI project description text
_projectDesc :: [Char]

-- | MEI element for MIDI instrument number (1-indexed)
midiInstrumentNum :: Int -> String

-- | MIDI instrument for playback
_midiInstrument :: String

-- | Plug in variables and musical content needed to boilerplate MEI
--   document in all its baroque verbosity
meiDocument :: String -> String -> String -> String -> String -> String -> String
instance GHC.Classes.Eq Scribo.MEI.ListPosition
instance GHC.Show.Show Scribo.MEI.ListPosition
instance GHC.Enum.Enum Scribo.MEI.ListPosition
